---
layout:     post
title:      高性能 IO 的设计
subtitle:   一个内存数据库的设计与实现（一）
date:       2021-04-01
author:     John Mactavish
header-img: img/post-bg-dog-lake.jpg
catalog: true
tags:
     - 软件设计

---

这是我看了《Redis 设计与实现》后一时兴起决定做的项目。它会帮助我熟悉高性能 IO、持久化机制甚至分布式算法。

高性能数据库少不了高性能的 I/O 模块。
高性能的 I/O 牵扯到特定的系统调用，而一般我们的服务器都使用 Linux 系统，所以下面也只讨论 Linux。

I/O 按其是否阻塞调用者可分为阻塞 IO（Blocking I/O，简称 BIO）与非阻塞 IO（NonBlocking I/O，简称 NIO）。
阻塞 I/O 在无法从缓冲区获得数据时会持续等待，而非阻塞 I/O 则始终立刻返回。下面的例子来自《Unix 环境高级编程（第三版）》
的第十四章：

```c
#include "apue.h"
#include <errno.h>
#include <fcntl.h>

char buf[5000];

int main(void) {
  int ntowrite, nwrite;
  char *ptr;

  ntowrite = read(STDIN_FILENO, buf, sizeof(buf)); // 阻塞读，等待终端输入
  fprintf(stderr, "read %d bytes\n", ntowrite);

  set_fl(STDOUT_FILENO, O_NONBLOCK); // 设置非阻塞写

  ptr = buf;
  while (ntowrite > 0) {
    errno = 0;
    nwrite = write(STDOUT_FILENO, ptr, ntowrite); // write 会立即返回
    fprintf(stderr, "nwrite = %d, errno = %d\n", nwrite, errno); // 未读到数据时，errno 不为 0

    if (nwrite > 0) { // 读到了 nwrite 个字节的数据
      ptr += nwrite;
      ntowrite -= nwrite;
    }
  }
  clr_fl(STDOUT_FILENO, O_NONBLOCK);
  exit(0);
}
```

对于一个给定的描述符，有两种为其指定 NIO 的方法。

- 在用 open 系统调用打开时，指定 O_NONBLOCK 标志
- 对于已打开的描述符，调用 fcntl 打开 O_NONBLOCK 标志

注意阻塞 I/O 并不会导致忙等待而浪费 CPU 时间，操作系统会挂起阻塞的线程，调度其他线程执行。
那除了编程风格的不同，它们还有什么区别吗？当然有。我们程序的处理流程一般是读 I/O、计算、写 I/O。
为了提高程序并发性，同时服务更多的客户，我们需要同时进行大量的这个相同的流程。

一种直觉的思路是引入多线程，
所有的线程执行相同的流程。但是多线程不是银弹（Silver Bullet）。当线程数量与 CPU 核心数相当时，多线程可以
被调度到不同的核心上并行进行；而线程数远大于核心数时，会出现频繁的线程调度，线程数越多，上下文切换所花时间占 CPU 总时间
的比例越高（即效率越低）。参考陈硕的经验公式，设密集计算所占的时间比重为 `P（0<P≤1）`，而系统一共有 C 个 CPU，
为了让这 C 个 CPU 跑满而又不过载，线程池大小的经验公式 `T＝C/P`。考虑到 P 值的估计不是很准确，T 的最佳值可以上下浮动 50％。
那么对于完全的计算密集型程序，线程数应等于核心数，更多的线程反而会降低效率，拖慢程序；考虑我们上面的处理流程，
最匹配的线程数也不会太大，距离动辄几万的并发数相距遥远。一种改进的方法是让线程变得更轻量化，这样一来，我们就能低开销地创建大量
线程了，参考 Go 的协程；但是这不是这篇文章的重点。

那么在有限的线程数下要如何提高并发数呢。现在非阻塞 I/O 可以派上用场了。我们可以用一个线程来专门处理 I/O，其他线程则只处理计算。
I/O 线程可以同时轮询多个 I/O，把就绪的 I/O 加入计算线程池的处理队列中。

```c#
// 创建TCP套接字并绑定端口8888，进行服务监听
listenfd = serverSocket(8888,"tcp");
clientFdSet = empty_set();
while(true){ // 开启事件监听循环
    // accept同步非阻塞调用,判断是否接收了新的连接
    newfd = acceptNonBlock(listenfd);

    if(newfd != EMPTY){
        // 如果存在新连接将其加入监听连接集合
        clientFdSet.add(newfd);
    }
    // 申请一个1024字节的缓冲区
    buffer = new buffer(1024);
    for(clientfd in clientFdSet){
        // 非阻塞read读
        num = readNonBlock(clientfd,buffer);
        if(num > 0){
            // 读缓冲区存在数据
            data = buffer;
            ... dosomething
            if(needClose(data)){
                // 关闭连接时，移除当前监听的连接
                clientFdSet.remove(clientfd)；
            }
        }
        ... dosomething
        // 清空buffer
        buffer.clear();
    }
}
```

但是**注意每个文件描述符对应的 I/O 状态查询，都必须通过一次 NIO 系统调用（readNonBlock）才能完成。
在循环中反复进行系统调用限制了这种方案的效率。**

为此，Linux 又提供了 I/O 多路复用（I/O Multiplexing）的系统调用以与 NIO 系统调用配套使用。
I/O 多路复用允许一次传递许多个文件描述符进行批量的 I/O 状态查询，一次系统调用就能得到所有文件描述符的 I/O 状态。
Linux 的 I/O 多路复用有三种系统调用：select、poll、epoll。

select 系统调用本身是同步、阻塞的，当所传递的文件描述符集合中都没有就绪的 I/O 事件时，执行 select 系统调用的线程将会进入阻塞态，
直到至少一个文件描述符对应的 I/O 事件就绪，则唤醒被 select 阻塞的线程。唤醒后获得 CPU 的线程在 select 系统调用返回后可以遍历所传入的文件描述符集合，处理完成了 I/O 事件的文件描述符。

```c#
// 创建TCP套接字并绑定端口8888，进行服务监听
listenfd = serverSocket(8888,"tcp");
fdNum = 1;
clientFdSet = empty_set();
clientFdSet.add(listenfd);
while(true){ // 开启事件监听循环
    // man 2 select(查看linux系统文档)
    // int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
    // 参数nfds：一共需要监听的readfds、writefds、exceptfds中文件描述符个数+1
    // 参数readfds/writefds/exceptfds： 需要监听读、写、异常事件的文件描述符集合
    // 参数timeout：select是同步阻塞的，当timeout时间内都没有任何I/O事件就绪，则调用线程被唤醒并返回(ret=0)
    //         timeout为null代表永久阻塞
    // 返回值ret：
    //  1.返回大于0的整数，代表传入的readfds/writefds/exceptfds中共有ret个被激活(需要应用程序自己遍历)，
    //  2.返回0，在阻塞超时前没有任何I/O事件就绪
    //  3.返回-1，出现错误

    listenReadFd = clientFdSet;
    // select多路复用，一次传入需要监听事件的全量连接集合（超时时间1s）
    result = select(fdNum+1,listenReadFd,null,null,timeval("1s"));
    if(result > 0){
        // 如果服务器监听连接存在读事件
        if(IN_SET(listenfd,listenReadFd)){
            // 接收并建立连接
            newClientFd = accept(listenfd);
            // 加入客户端连接集合
            clientFdSet.add(newClientFd);       
            fdNum++;
        }
        
        // 遍历整个需要监听的客户端连接集合
        for(clientFd : clientFdSet){
            // 如果当前客户端连接存在读事件
            if(IN_SET(clientFd,listenReadFd)){
                // 阻塞读取数据
                data = read(clientfd);
                ... dosomething
                
                if(needClose(data)){
                    // 关闭连接时，移除当前监听的连接
                    clientFdSet.remove(clientfd)；            
                    fdNum--;
                }
            }
        }
    }
}
```


---

> 参考资料：
>
> [“小熊餐馆” 的文章](https://my.oschina.net/u/4504531/blog/4718645)
>
> 《Unix 环境高级编程（第三版）》第十四章
>
> 《Linux 高性能服务器编程》
>
> 《Linux 多线程服务端编程》

如果你喜欢我的文章，请我吃根冰棒吧  (o゜▽゜)o ☆

![contribution](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/contribution.jpg)

> 最后附上 GitHub：<https://github.com/gonearewe>
