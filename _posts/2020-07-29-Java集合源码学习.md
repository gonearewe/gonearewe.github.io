---
layout:     post
title:      Java集合源码学习
subtitle:   源码阅读笔记
date:       2020-07-29
author:     John Mactavish
header-img: img/post-bg-city-dawn.jpg
catalog: true
tags:
     - Java
     - 集合
     - 源码
---

# 前言

暑假闲来无事，看看 Java 标准库源码。直接看下载的源码当然优先级排最后，毕竟真正的源码
可能受性能、边界条件等因素影响搞出一些不明所以的东西出来破坏阅读体验（所幸看的是 Java 的……），
同时为了梳理代码的架构设计可能还要非常麻烦地动用 SourceInsight （我没用过）之类的东西，
即使如此得到的静态类、接口层次结构中也可能包含各种 AbstractClass 之类的对理解没有帮助的中间层次。
所以我理所当然地选择了跟着 Github 上现有的源码阅读项目走，毕竟中国“课代表”向来有着记笔记与分享笔记的
好习惯。目前跟的是[这个](https://github.com/vitrun/JDK1.8)，
其中集合模块[在这](http://wangkuiwu.github.io/2012/02/01/collection-00-index/)。
上面有的基本不会复读，博文主要记录自己的发现与感悟，可能会引用一些内容和源码以保证结构完整。

***

2020-07-30 更新：今天我更新 LinkedList 部分的时候发现上面的那个集合模块笔记里的代码并不是 JDK 里面的
源码……无语，现在跟着[这一个仓库](https://github.com/wupeixuan/JDKSourceCode1.8)。

# 集合主要框架

Java 集合工具包位于 java.util 中，主要有 4 个部分：List、Set、Map 和
工具类(Iterator、Enumeration、Arrays 与 Collections)。
包括接口在内的层次结构用一张图足以说明：

![collection](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-collection.jpg)

有关 UML 的类图(class diagram)可以在[这里](https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/)找到简单教程。
继承、实现关系对应哪些 Java 语法不言而喻；至于依赖关系，它指的是一个类的字段或方法局部变量、参数、
返回值中用到了另一个类。比如说图中的 Collection 的实现类都要实现 iterator() 函数，
返回一个 Iterator 对象，那我们认为 Collection 依赖于 Iterator。

# ArrayList

ArrayList 是线程不安全的支持随机访问功能的泛型动态数组，是 Java 集合中最常被用到的类之一。

## 构造函数

<pre>
// 默认构造函数
ArrayList()

// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。
ArrayList(int capacity)

// 创建一个包含collection的ArrayList
ArrayList(Collection&lt;? extends E> collection)
</pre>

## 继承关系与类声明

<pre>
java.lang.Object
   ↳     java.util.AbstractCollection&lt;E>
         ↳     java.util.AbstractList&lt;E>
               ↳     java.util.ArrayList&lt;E>

public class ArrayList&lt;E> extends AbstractList&lt;E>
        implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable {}
</pre>

## 类字段与方法

字段有：

<pre>
    // 序列版本号
    private static final long serialVersionUID = 8683452581122892189L;

    // 保存ArrayList中数据的数组
    private transient Object[] elementData;

    // ArrayList中实际数据的数量
    private int size;
</pre>

注意 elementData 前的 transient(易失) 关键字，它表示这个字段不会在对象序列化时被存储。
记得我们上面提到了 ArrayList 是可序列化的类（实现了 java.io.Serializable），
那么 elementData 不是 ArrayList 具体存放元素的地方吗？对象序列化时为什么不要了？
原来 ArrayList 为序列化的两个方法提供了自己的实现:

<pre>
// 将ArrayList的“容量，所有的元素值”都写入到输出流中
private void writeObject(java.io.ObjectOutputStream s)
    throws java.io.IOException{
    // Write out element count, and any hidden stuff
    int expectedModCount = modCount;
    s.defaultWriteObject();

    // 写入“数组的容量”
    s.writeInt(elementData.length);

    // 写入“数组的每一个元素”
    for (int i=0; i< size; i++)
        s.writeObject(elementData[i]);

    if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
    }
}

// 先将ArrayList的“容量”读出，然后将“所有的元素值”读出
private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    // Read in size, and any hidden stuff
    s.defaultReadObject();

    // 从输入流中读取ArrayList的“容量”
    int arrayLength = s.readInt();
    Object[] a = elementData = new Object[arrayLength];

    // 从输入流中将“所有的元素值”读出
    for (int i=0; i< size; i++)
        a[i] = s.readObject();
}
</pre>

而不使用默认实现的原因是 elementData 只是一个缓存数组，它通常会预留一些容量，
那里没有实际存储元素，直接序列化整个数组会浪费空间和时间。注意自己的实现中 ArrayList 的 size
即为实际存储的元素的个数，而 capacity 则需要单独记录下来。

ArrayList 的一个构造器实现如下：

<pre>
// ArrayList 带容量大小的构造函数。
public ArrayList(int initialCapacity) {
    super();
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity);
    // 新建一个数组
    this.elementData = new Object[initialCapacity];
}
</pre>

它检查了参数的有效性，并为无效参数抛出自己的异常，这是库代码的一个 best practice。
如果用户使用库时触发了 IndexOutOfBoundException 这类底层异常而不得不开始阅读库代码寻找答案，
那么这个库的设计就很有问题，它没有构建好自己的抽象层。

trimToSize 方法调用 Arrays.copyOf 新建一个长度刚好为 size 的副本代替原来的缓存数组；
因为 ArrayList 的容量就是缓存数组的长度，而 Java 中数组长度不可以改变，所以只有
新建副本一条路可走。因此，无疑这个方法的时间复杂度为 O(n)（具体参考
[这个问题](https://stackoverflow.com/questions/7165594/time-complexity-of-system-arraycopy)，
native 方法会有优化，比自己写 for 循环快，但肯定还是 O(n)），开销有一点反直觉，还是不要
闲着没事经常用为好。

<pre>
// 将当前容量值设为等于实际元素个数
public void trimToSize() {
    modCount++;
    int oldCapacity = elementData.length;
    if (size < oldCapacity) {
        elementData = Arrays.copyOf(elementData, size);
    }
}
</pre>

ensureCapacity(int minCapacity) 调用后保证 capacity 至少为 minCapacity。
可以猜到如果 capacity 足够大，方法会立即返回；
但是注意它没说“如果 capacity 较小，则把它扩充到 minCapacity”。事实上，源码表明，
它首先尝试设置“新的容量=(原始容量x3)/2 + 1”，假如这还不够，它才会把 capacity 扩充到 minCapacity。
当然，只要改变了 capacity，就会导致内部缓存数组的复制。其实，ArrayList 中其他添加元素
的方法使用的都是这个 public 方法，也就是这里的扩容策略决定了 ArrayList 的扩容策略。

<pre>
// 确定ArrarList的容量。
// 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1”
public void ensureCapacity(int minCapacity) {
    // 将“修改统计数”+1
    modCount++;
    int oldCapacity = elementData.length;
    // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1”
    if (minCapacity > oldCapacity) {
        Object oldData[] = elementData;
        int newCapacity = (oldCapacity * 3)/2 + 1;
        if (newCapacity < minCapacity)
            newCapacity = minCapacity;
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
}
</pre>

contains 内部实现用的是 indexOf 方法，这并不意外。

<pre>
// 返回ArrayList是否包含Object(o)
public boolean contains(Object o) {
    return indexOf(o) >= 0;
}
</pre>

关于 toArray 方法，我一年前写过[一篇文章](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/_posts/2019-08-21-Java刷题知识点.md)简单提过，
难以想象我一年前水平竟然如此之低，不忍直视……今天再来详细讲一讲。

<pre>
// 返回ArrayList的Object数组
public Object[] toArray() {
    return Arrays.copyOf(elementData, size);
}

// 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型
public &lt;T> T[] toArray(T[] a) {
    // 若数组a的大小 < ArrayList的元素个数；
    // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中
    if (a.length < size)
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());

    // 若数组a的大小 >= ArrayList的元素个数；
    // 则将ArrayList的全部元素都拷贝到数组a中。
    System.arraycopy(elementData, 0, a, 0, size);
    if (a.length > size)
        a[size] = null;
    return a;
}
</pre>

对于第一个重载方法，还是借用一年前的例子：

<pre>
ArrayList&lt;String> list=new ArrayList&lt;String>();
for (int i = 0; i < 10; i++) {
    list.add(""+i);
}
String[] array= (String[]) list.toArray();

// Exception in thread "main" java.lang.ClassCastException: 
// [Ljava.lang.Object; cannot be cast to [Ljava.lang.String;
</pre>

这个会报错的原因是 Java 数组不支持逆变，Object[] 变量不能强制转为 String[]，即使它
确实应该是 String[]（当然，数组可以协变，所以反过来总是可以的，具体参考
[上一篇文章](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/_posts/2020-07-26-泛型的协变与逆变.md)）。

至于第二个重载方法，就比较有意思了。它把 ArrayList 转化为特定类型的数组，如果传入的
数组足够大，它会把 ArrayList 里的内容写进这个数组，否则会创建一个新数组。
我相信你一定和我当初一样，好奇为什么需要传入一个数组作为参数，它不能自己新建一个并返回吗。
答案是类型擦除。而关键在于返回的是数组，倘若是其他泛型类就无所谓了，反正大家用的其实
都是 Object，而数组在创建时需要知道它内部元素的具体类型。那就得想办法给它类型信息喽。
数组参数的意义更在于它的类型(a.getClass())而不是数组本身。当然了，更现代化的写法是:

<pre>
public &lt;T> T[] toArray(Class&lt;T> elementType)
</pre>

这样写明确指出了我们要的是类型信息，不过，为了兼容性只能够妥协，继续沿用以前的方法签名。

另外注意 toArray(T[] a) 是怎么定义的：

<pre>
class ArrayList&lt;T>{
  // ...
    public T[] toArray(T[] a){
      // ...
    }
}

class ArrayList&lt;T>{
  // ...
    public &lt;T> T[] toArray(T[] a){
      // ...
    }
}

class ArrayList&lt;T>{
  // ...
    public &lt;E> E[] toArray(E[] a){
      // ...
    }
}
</pre>

前两者是不一样的，第一个 toArray 的类型参数 T 与 ArrayList&lt;T&gt; 中的 T 是同一的。但
第二个使用尖括号语法定义了一个新的 T，隐藏(hide)了 ArrayList&lt;T&gt; 中的 T,它实际上与
第三个是相同的。换句话说，泛型方法的类型参数与泛型类的类型参数无关。这样设计是为了把数组类型
的选择权交给使用者，毕竟使用者未必就想要把 ArrayList&lt;Integer&gt; 变成 Integer[],也许
要的是 Number[] 或者 Object[]。

<pre>
ArrayList&lt;Integer> list; // ArrayList&lt;T> 的 T 是 Integer
Integer[] array = list.toArray(new Integer[0]); 
Number[] array = list.toArray(new Number[0]); // 泛型方法的 T 是 Number
Object[] array = list.toArray(new Object[0]); // 泛型方法的 T 是 Object
</pre>

ArrayList 里的 remove 方法用到了下面这个辅助方法：

<pre>
// 快速删除第 index 个元素
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    // 从"index+1"开始，用后面的元素替换前面的元素。
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                          numMoved);
    // 将最后一个元素设为null
    elementData[--size] = null; // Let gc do its work
}
</pre>

它和其他的多个方法一样，使用 

> public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)

令参数 src 与 dest 为同一个数组，在其上覆盖元素以完成删除功能，整体偏移元素以为待添加元素腾出空间。

clear 会将 size 置 0，同时把元素都置 null(O(n)时间复杂度)，以便于 GC 回收。它不会修改 capacity。

<pre>
// 清空ArrayList，将全部的元素设为null
public void clear() {
    modCount++;

    for (int i = 0; i < size; i++)
        elementData[i] = null;

    size = 0;
}
</pre>

ArrayList 是并发不安全的，但是它提供了 fail-fast 机制来检测不安全状态并抛出异常。
比如说，当通过 iterator 去遍历某集合时，若该集合的内容在期间被改变了，
那么 iterator 下一次访问集合时，就会抛出 ConcurrentModificationException 异常。
结合源码即可了解它的原理。

<pre>
public abstract class AbstractList&lt;E> extends AbstractCollection&lt;E> implements List&lt;E> {

    ...

    // AbstractList中唯一的属性
    // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1
    protected transient int modCount = 0;

    // 返回List对应迭代器。实际上，是返回Itr对象。
    public Iterator&lt;E> iterator() {
        return new Itr();
    }

    // Itr是Iterator(迭代器)的实现类
    private class Itr implements Iterator&lt;E> {
        int cursor = 0;

        int lastRet = -1;

        // 修改数的记录值。
        // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；
        // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；
        // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size();
        }

        public E next() {
            // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；
            // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。
            checkForComodification();
            try {
                E next = get(cursor);
                lastRet = cursor++;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }

        public void remove() {
            if (lastRet == -1)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.remove(lastRet);
                if (lastRet < cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount; // 更新
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }

    ...
}
</pre>

注意三点：第一，fail-fast 发生的时机是在尝试读不安全状态时而非破坏正常状态（并发修改集合）时；
第二，fail-fast 机制是“尽力而为”的，它不保证总可以检测到不安全状态；

> From Java Docs
>
> The iterators returned by this class's iterator and listIterator methods are fail-fast: 
> if the list is structurally modified at any time after the iterator is created, 
> **in any way except through the iterator's own remove or add methods**, 
> the iterator will throw a ConcurrentModificationException. Thus, 
> in the face of concurrent modification, the iterator fails quickly and cleanly, 
> rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.
>
> Note that the fail-fast behavior of an iterator cannot be guaranteed as it is, 
> generally speaking, impossible to make any hard guarantees in the presence of unsynchronized 
> concurrent modification. **Fail-fast iterators throw ConcurrentModificationException on a 
> best-effort basis.** Therefore, it would be wrong to write a program that depended on 
> this exception for its correctness: **the fail-fast behavior of iterators should be used 
> only to detect bugs.**

第三，fail-fast 是 iterator 支持的，它不仅仅可以检测多线程并发导致的不安全状态，
看下面的[来自 Stack Overflow的例子](https://stackoverflow.com/questions/10690903/arraylist-concurrent-modification#:~:text=Iterator%20of%20ArrayList%20is%20fail,ConcurrentModificationException%20and%20will%20bail%20out.)：

<pre>
for(Iterator&lt;String> itpendingmsgs = pendingmsgs.iterator(); itpendingmsgs.hasNext();) {
    String pendingmsg = itpendingmsgs.next();
    String dest = pendingmsg.substring(4);              
    if (protocol.author.equals(dest)) {
        sendMsg(msg);
        pendingmsgs.remove(pendingmsg); // WRONG
        // itpendingmsgs.remove(); // CORRECT
        // use iterator's own remove or add methods
    }
}
</pre>

另外看一下下面的例子：

<pre>
public static void main(String[] args) {
    ArrayList&lt;Integer> li = new ArrayList&lt;>();
    li.add(0);li.add(1);li.add(2);li.add(3);li.add(4);

    // 增强型 for 循环是 iterator 的语法糖
    for (var e: li) { // java.util.ConcurrentModificationException
        li.remove(e); 
    }
    System.out.println(li);
}

public static void main(String[] args) {
    ArrayList&lt;Integer> li = new ArrayList&lt;>();
    li.add(0);li.add(1);li.add(2);li.add(3);li.add(4);

    for (int i = 0; i < li.size(); i++) {
        li.remove(i); // 删除元素导致其他元素索引变化
    }
    System.out.println(li); // 输出 [1, 3]
}
</pre>

所以，**唯一一个可以安全地边遍历边修改集合的方法是显式使用 iterator 和它的 remove 或者 add 方法。**

# LinkedList

## 构造函数

<pre>
// 默认构造函数：创建一个空的链表
LinkedList()

// 包含“集合”的构造函数:创建一个包含“集合”的LinkedList
LinkedList(Collection&lt;? extends E> c)
</pre>

## 继承关系与类声明

<pre>
java.lang.Object
   ↳     java.util.AbstractCollection&lt;E>
         ↳     java.util.AbstractList&lt;E>
               ↳     java.util.AbstractSequentialList&lt;E>
                     ↳     java.util.LinkedList&lt;E>

public class LinkedList&lt;E>
    extends AbstractSequentialList&lt;E>
    implements List&lt;E>, Deque&lt;E>, Cloneable, java.io.Serializable {}
</pre>

## 类字段与方法

字段有：

<pre>
    transient int size = 0;
    transient Node&lt;E> first; // 指向头结点
    transient Node&lt;E> last; // 指向尾结点
</pre>

注意一个重要的内部类 Node，它代表双向链表的一个结点，所以 LinkedList 就是一个双向链表。

<pre>
// 双向链表的节点所对应的数据结构。
// 包含3部分：上一节点，下一节点，当前节点值。
private static class Node&lt;E> {
    E item;
    LinkedList.Node&lt;E> next;
    LinkedList.Node&lt;E> prev;

    Node(LinkedList.Node&lt;E> prev, E element, LinkedList.Node&lt;E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
</pre>

LinkedList 的一些基本操作都分为两组：removeFirst/removeLast、
getFirst/getLast、addFirst/addLast，它们分别对应为在链表头尾处的操作。
对于输入参数是元素对象的方法，LinkedList 的处理逻辑与 ArrayList 一致：add(E e) 添加到
链表的最后（等同于 addLast），remove(Object o) 从前面开始查找（等同于 removeFirst）。
而对于输入参数是元素索引的方法，都用到了下面的方法来寻找指定元素，时间复杂度是 O(n/2)。

<pre>
// 获取指定下标的结点，index从0开始
Node&lt;E> node(int index) {
    // 如果指定下标小于一半元素数量，则从首结点开始遍历
    // 否则，从尾结点开始遍历
    if (index < (size >> 1)) {
        Node&lt;E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node&lt;E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
</pre>

clear 方法并不是只删除了头尾结点了事，而是遍历了整个链表，置空了所有结点，
与 ArrayList 一样是 O(n) 时间复杂度。

<pre>
// 清空双向链表
public void clear() {
    //遍历链表，删除所有结点,方便gc回收垃圾
    for (Node&lt;E> x = first; x != null; ) {
        Node&lt;E> next = x.next;
        x.item = null;
        x.next = null;
        x.prev = null;
        x = next;
    }
    // 首尾结点置空
    first = last = null;
    // 元素数量置0
    size = 0;
    modCount++;
}
</pre>

LinkedList 实现了 Deque（读作 deck），而 Deque 接口定义了在双端队列两端访问元素的方法。
提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，
另一种形式返回一个特殊值（null 或 false，具体取决于操作）。同时，
LinkedList 既可以作为 FIFO(先进先出) 的队列，又可以作为 LIFO(后进先出) 的栈，有着
对应数据结构的特殊名称方法。感觉给简单的几个功能起了好多名字……

![Linked List](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-linkedlist.jpg)

LinkedList 的 iterator 也支持 fail-fast 机制，这里就不再重提了。

最后提一下，我一开始参考的[源码笔记](http://wangkuiwu.github.io/2012/02/05/collection-05-linkedlist/)
中给出的代码并不是 JDK 的真正代码，不过写法也很有趣。它是这样设计字段的：不保存头尾结点的引用，
转而保存了一个不包含实际数据的哨兵节点。

<pre>
    // 链表的表头，表头不包含任何数据。
    private transient Entry&lt;E> header = new Node&lt;E>(null, null, null);

    // LinkedList中元素个数
    private transient int size = 0;
</pre>

在默认的构造函数中，初始化哨兵结点 header 的指针都指向自己。

<pre>
// 默认构造函数：创建一个空的链表
public LinkedList() {
    header.next = header.prev = header;
}
</pre>

addFirst 把元素添加在哨兵结点 header 之后（让 header.next 指
向它），addLast 则把元素添加在哨兵结点 header 之前（让 header.prev 指向它）。
那么，有元素的 LinkedList 的内部模型如下图所示，header 连接双向链表的头和尾形成环形，
这样只需要一个哨兵结点就可以控制两个端点。

<pre>
   last          first
    6 -- header -- 0
    |              |
    5              1
    |              |
    4 --    3   -- 2

size = 7
header.next = 0
header.prev = 6
</pre>

***  
> 最后附上GitHub：<https://github.com/gonearewe>

