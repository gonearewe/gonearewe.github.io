---
layout:     post
title:      RocketMQ 笔记
subtitle:   分布式软件设计
date:       2021-05-01
author:     John Mactavish
header-img: img/post-bg-red-dead-grass-tree-sun.jpg
catalog: true
tags:
     - RocketMQ
     - 分布式
     
---

使用量大的业务通常由多台服务器（数据库服务器、缓存服务器、计算服务器等）配合支持。服务器间的配合离不开通信。
通常我们使用这样的模型描述它们间的关系：一组同构的服务器为生产者（Producer），
另一组为消费者（Consumer），它们间的通信称为消息（Message）。消息的传递一般有两种模式：推式（PUSH）与拉式（PULL）。
无论是哪种，都要求其中一组事先知道另一组的位置以主动与其通信。例如，相对于生产者的推式要求生产者记录下消费者服务器的 IP 地址、
通信协议等，
在集群启动后，生产者主动找上消费者并为其提供服务。但是，无论是哪一方都是易变的，单个服务器可能会故障下线或需要维护，
服务器规模因业务量变化可能会扩展或收缩。让其中一方在配置中写死对方的信息，耦合性实在是太大了。**当然，耦合是模块协同工作的必要，
但是耦合不应该发生在两个经常变化的模块之间。**为了解耦，我们常见的策略便是引入中间层。这里的中间层就是消息中间件。
生产者与消费者通过消息中间件协同工作，彼此间不再直接通信。中间件一般采用队列模型，即生产者把生产的服务放进中间件中，
中间件按 FIFO 顺序提供给需要的消费者。所以这样的中间件又叫做消息队列，常见的产品有 ActiveMQ、RabbitMQ、RocketMQ 和 Kafka 等。

本文以 RocketMQ 为例介绍消息队列的设计，参考书籍《RocketMQ 技术内幕：RocketMQ 架构设计与实现原理》。

RocketMQ 的设计为基于主题（Topic）的订阅发布机制：消息生产者发送某一主题的消息到消息服务器，消息服务器暂存该消息，
消息消费者订阅感兴趣的主题，消息服务器根据订阅信息（路由信息）将消息推送到消费者（推式）或者消息消费者主动向消息服务器拉取消息（拉式）。 
主题相当于命名空间，可以对消息进行分类；同一主题的消息可以分布在多个消息服务器上以提高可用性。某个消息服务器上的单个主题的消息
也可能分布在多个队列中，后面会解释设计多个队列的原因。

![queue](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/post-2021-rocketmq-queue.jpg)

RocketMQ 本身一般也工作在集群模式下（以防单点故障导致整个系统瘫痪），所以如果让生产者或消费者去记住每个 RocketMQ 服务器的信息，耦合还是不小的。
因此 RocketMQ 引入了路由中心 NameServer，用于路由主体部分———— Broker 消息服务器。

![name-server](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/post-2021-rocketmq-nameserver.jpg)

Broker 消息服务器在启动时向所有 NameServer 注册，消息生产者在发送消息前先从 NameServer 获取 Broker 服务器地址列表，
然后根据负载算法从列表中选择一台消息服务器进行消息发送。NameServer 与每台 Broker 服务器保持长连接，
并间隔 10s 检测 Broker 是否存活（Broker 每 30s 应向 NameServer 发送一个心跳包，心跳包中同时包含主题的路由信息），
如果检测到 Broker 宕机（最近的心跳包的时间戳在 120s 前），则从路由注册表中将其移除。但是路由变化不会马上通知消息生产者，
取而代之的是消息生产者以每 30s 的频率去拉取主题的路由信息，它在此时才会知道。
NameServer 本身的高可用可通过部署多台 NameServer 服务器来实现，但彼此之间互不通信，也就是 NameServer 服务器之间在某一时刻的数据并不会完全相同，但这对消息发送不会造成任何影响。

某个生产者向某个主题提交消息时需要确定向哪个服务器的哪个队列提交。生产者采用 Round Robin 算法进行负载均衡，
即把第一个消息发给第一个队列，第二个消息发给第二个队列……到了队列尾后下一个消息再循环回第一个队列。自然，消息发送可能失败，
此时理论上应把它重发给下一个队列，但是如果下一个队列是在同一个机器上的，鉴于发送失败原因可能是机器故障或通向其的网络拥塞，
重发再次失败概率较高。所以可采用一些退避策略，比如发送失败后 5 分钟内不会再次选择该 Broker 上的队列，进一步的，如果发送的延时（latency）较大，
也可进行一定程度的退避。

![producer-1](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/post-2021-rocketmq-producer-1.jpg)

![producer-2](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/post-2021-rocketmq-producer-2.jpg)

---
如果你喜欢我的文章，请我吃根冰棒吧  (o゜▽゜)o ☆

![contribution](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/contribution.jpg)

> 最后附上 GitHub：<https://github.com/gonearew