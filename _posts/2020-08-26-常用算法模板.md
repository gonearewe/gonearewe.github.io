---
layout: post
title: 常用算法模板
subtitle: 算法练习笔记
date: 2020-08-26
author: John Mactavish
header-img: img/post-bg-yellowstone-hotwater.jpg
catalog: true
tags:
  - 算法
---

# DFS

模板如下：

```
void dfs(int 当前状态)
{
      if(当前状态为边界状态)
      {
        记录或输出
        return;
      }
      for(每一个子状态)		//横向遍历解答树所有子节点
      {
            修改了全局变量
            if(子状态满足约束条件)
            {
              dfs(子状态)
            }
            恢复全局变量//回溯部分
      }
}
```

实例：

```
# 题目：输出一个数组中所有元素的全排列

def full_permutation(arr):
    visited = [1] * len(arr)
    temp = arr[:] # 浅拷贝
    result = []
    def dfs(position):
        if position == len(arr):
            result.append(temp[:])  # 浅拷贝，否则result中所有行都一样
            return
        for index in range(len(arr)):
            if visited[index]:
                temp[position] = arr[index]
                visited[index] = 0
                dfs(position+1)
                visited[index] = 1
    dfs(0)
    return result

print(full_permutation([1,2,3]))
# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]


// 题目：给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

// 示例:
// 输入: [4, 6, 7, 7]
// 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

// 说明:
// 给定数组的长度不会超过15。
// 数组中的整数范围是 [-100,100]。
// 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

import java.util.ArrayList;
import java.util.List;

class Solution { // 递归枚举
    private List<List<Integer>> res = new ArrayList<>();
    private int[] nums;

    public List<List<Integer>> findSubsequences(int[] nums) {
        this.nums = nums;
        backtrace(new ArrayList<Integer>(), 0, Integer.MIN_VALUE);
        return res;
    }

    private void backtrace(List<Integer> path, int cur, int last) {
        if (cur >= nums.length) {
            if (path.size() >= 2) {
                res.add(new ArrayList<>(path));
            }
            return;
        }

        if (last != nums[cur]) { // last 用于防止重复枚举
            // 两个相同元素有四种情况：
            //     前者被选择，后者被选择
            //     前者被选择，后者不被选择
            //     前者不被选择，后者被选择
            //     前者不被选择，后者不被选择
            // 第二种情况和第三种情况是重复的，我们令“前者被选择时后者必被选择”，舍弃了第二种
            backtrace(path, cur + 1, last);
        }
        if (nums[cur] >= last) {
            path.add(nums[cur]);
            backtrace(path, cur + 1, nums[cur]);
            path.remove(path.size() - 1);
        }
    }
}
```

# 二分搜索

![binary search 1](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-binarysearch-1.jpg)
![binary search 2](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-binarysearch-2.jpg)

几个值得注意的点分别是：

<!-- 区间为左闭右开，即 `[left, right)`。好处有三：一来分隔区间比较自然，表示为 `[left, mid)` 和 `[mid, right)`；
二来区间两端值的差正好是区间的长度，如 `[0, 4)` 的区间长度为 `4 - 0 = 4`；最后方便表示空区间，此时两端值
相等，如 `[0,0)`。 -->

1）区间为左闭右闭，即 `[left, right]`，循环内部的隐性约束是要搜索的数（如果存在的话）在当前搜索的闭区间内。

2）while **循环的条件是 `left < right` 而不是 `left <= right`**，这样循环终止时，必有 `left == right`，
使用任意一个都一样，不易出错。

3）区间长度是偶数时涉及到左右中位数的问题，比如 `[0,3]` 的中位数有 `1` 和 `2` 两个。
常见的中位数写法有三种：

| 左中位数                        | 右中位数                          |
| :------------------------------ | :-------------------------------- |
| mid = (left + right) / 2        | mid = (left + right+1) / 2        |
| mid = left + (right - left) / 2 | mid = left + (right - left + 1) / 2 |
| (left + right) >>> 1            | (left + right + 1) >>> 1          |

在默认 `left` 和 `right` 是数组索引，为自然数时，第一种写法
容易整数溢出，不考虑；第二种写法保证不会溢出；第三种写法使用的是 Java 的无符号右移，
即使加和溢出为负数了，移位后的结果仍然是正确的正中位数，这种写法看起来也比第二种清晰，推荐使用。
但是，在 `left` 和 `right` 可能为负数时，第一种使用的除 2 取商是向 0 取整的而不是向下取整的；
第三种写法会把负数移位成正数，直接就不对了；但第二种写法始终是正确的。

4）二分搜索一旦没写好很容易在区间只有两个数时进入死循环，所以判断中位数后一个边界应该在满足 1） 中的约束
的同时更加激进地缩小区间（`left = mid + 1` 或者 `right = mid - 1`）。**同时中位数应该选择更加激进的那一边的，
即 `left = mid + 1` 对应左中位数，`right = mid - 1` 对应右中位数。**

5）至于书写思路，建议先写分支逻辑，并且**先写排除中位数的逻辑分支（因为更多时候排除中位数的 `if` 条件
容易想，不过这并不绝对），另一个分支的逻辑你就不用想了，`else` 就是它的取反。再根据分支的情况
选择使用左中位数还是右中位数。**

# 数学与数字

```
// 把给定的数字分成指定位数的数组
// INPUT: 14458, num[5]
// OUTPUT: num[5]{8,5,4,4,1}
public static void numToArray(int number, int[] num) {
    for (int i = 0; i < num.length; i++) {
        num[i] = number % 10;
        number /= 10;
    }
}

// 把给定的数组变成数字
// INPUT: num[5]{8,5,4,4,1}
// OUTPUT: 14458, num[5]
public static int arrayToNum(int[] num) {
    int n;

    for (int i = 0; i < num.length; i++) {
        n = n * 10 + num[i];
    }

    return n;
}

// 求a,b的最小公约数，利用辗转相除法，其实是利用定理 gcd(a, b) == gcd(b, a % b)
// 由此可以递归，边界是 gcd(a, 0) == a
public static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }

    return gcd(b, a % 10);
}

// 求a,b的最小公倍数，利用上面求到的最小公约数 d，
// lcm = (a * b) / d，为了防止 a*b 溢出，写成 (a / d) * d
public static int lcm(int a, int b) {
    return a / gcd(a, b) * b;

}

// 分数，保存分子分母，方便起见，使用假分数
class Fraction {
    int up, down;

    // 化简，使其满足三个条件：
    // 1. 分母始终为正数
    // 2. 如果分子是0，则分母是1
    // 3. 分子分母最小公约数是1
    public void reduction() {
        if (down < 0) {
            down = -down;
            up = -up;
        }

        if (up == 0) {
            down = 1;
        } else {
            // 记得取绝对值
            int d = gcd(Math.abs(up), Math.abs(down));
            up /= d;
            down /= d;
        }
    }

    // 分数的除法，加减乘同理，返回自己，方便链式调用
    public Fraction dividedBy(Fraction f) {
        up *= f.down;
        down *= f.up;
        // 结果记得化简
        reduction();

        return this;
    }

    // 输出分三种情况：
    // 1. 如果分母为1，则是整数，只输出分子 
    // 2. 如果分子绝对值大于分母，则是假分数，可以选择按带分数形式输出
    // 3. 其他情况，是真分数直接输出
    public void print() {
        reduction();  // 记得先化简

        if (down == 1) {
            System.out.print(up);
        } else if (Math.abs(up) > down) {
            // 注意比较和输出分子时都要取绝对值
            System.out.printf("%d %d/%d", up / down, Math.abs(up) % down, down);
        } else {
            System.out.printf("%d/%d", up, down);
        }
    }
}

// 判断一个数是不是素数，注意1既不是素数又不是合数，因子只需要判断到这个数的开方
public static boolean isPrime(int n) {
    if (n <= 1) {
        return false;
    }

    int sqr = (int) Math.sqrt(n * 1.0);// 变量外提，强制类型转换，以优化循环速度
    for (int i = 2; i <= sqr; i++) { // 从2开始判断，注意i<=sqr含有等号
        if (n % i == 0) {
            return false;
        }
    }

    // 实践中，如果n比较小（10的9次方之内），可以简单的这样写
    // for(int i = 2; i * i <=n; i++){
    //     if(n % i == 0)
    //         return false;
    // }

    return true;
}

// 获取一张直到给定数的素数表，从小数字开始，每发现一个素数，就向后筛去这个素数的整倍数
public static ArrayList<Integer> getPrimeList(int max) {
    // 带标记表的方法
    boolean[] mark = new boolean[max + 1]; // 偏移1个单位，使索引与数字对应
    ArrayList<Integer> primes = new ArrayList<>();

    for (int i = 2; i <= max; i++) { // 从2开始
        if (!mark[i]) { // 注意，标记为false即是素数，否则不做任何处理
            primes.add(i);

            for (int j = i + 1; j <= max; j += i) { // 从i+1开始向后筛去整倍数，步进是i
                mark[j] = true;
            }
        }
    }

    return primes;
}
```

---

> 参考：[李威威的简书博客](https://www.jianshu.com/p/b6ad653fb2e1)
> 最后附上 GitHub：<https://github.com/gonearewe>
