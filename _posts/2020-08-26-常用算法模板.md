---
layout: post
title: 常用算法模板
subtitle: 算法练习笔记
date: 2020-08-26
author: John Mactavish
header-img: img/post-bg-yellowstone-hotwater.jpg
catalog: true
tags:
  - 算法
---

# DFS

模板如下：

```
void dfs(int 当前状态)
{
      if(当前状态为边界状态)
      {
        记录或输出
        return;
      }
      for(每一个子状态)		//横向遍历解答树所有子节点
      {
            修改了全局变量
            if(子状态满足约束条件)
            {
              dfs(子状态)
            }
            恢复全局变量//回溯部分
      }
}
```

实例：

```
# 题目：输出一个数组中所有元素的全排列

def full_permutation(arr):
    visited = [1] * len(arr)
    temp = arr[:] # 浅拷贝
    result = []
    def dfs(position):
        if position == len(arr):
            result.append(temp[:])  # 浅拷贝，否则result中所有行都一样
            return
        for index in range(len(arr)):
            if visited[index]:
                temp[position] = arr[index]
                visited[index] = 0
                dfs(position+1)
                visited[index] = 1
    dfs(0)
    return result

print(full_permutation([1,2,3]))
# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]


// 题目：给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

// 示例:
// 输入: [4, 6, 7, 7]
// 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

// 说明:
// 给定数组的长度不会超过15。
// 数组中的整数范围是 [-100,100]。
// 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

import java.util.ArrayList;
import java.util.List;

class Solution { // 递归枚举
    private List<List<Integer>> res = new ArrayList<>();
    private int[] nums;

    public List<List<Integer>> findSubsequences(int[] nums) {
        this.nums = nums;
        backtrace(new ArrayList<Integer>(), 0, Integer.MIN_VALUE);
        return res;
    }

    private void backtrace(List<Integer> path, int cur, int last) {
        if (cur >= nums.length) {
            if (path.size() >= 2) {
                res.add(new ArrayList<>(path));
            }
            return;
        }

        if (last != nums[cur]) { // last 用于防止重复枚举
            // 两个相同元素有四种情况：
            //     前者被选择，后者被选择
            //     前者被选择，后者不被选择
            //     前者不被选择，后者被选择
            //     前者不被选择，后者不被选择
            // 第二种情况和第三种情况是重复的，我们令“前者被选择时后者必被选择”，舍弃了第二种
            backtrace(path, cur + 1, last);
        }
        if (nums[cur] >= last) {
            path.add(nums[cur]);
            backtrace(path, cur + 1, nums[cur]);
            path.remove(path.size() - 1);
        }
    }
}
```

# 动态规划

```
给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。

一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。

请你返回乘积为正数的最长子数组长度。

示例  1：
输入：nums = [1,-2,-3,4]
输出：4
解释：数组本身乘积就是正数，值为 24 。

示例 2：
输入：nums = [0,1,-2,-3,-4]
输出：3
解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。

示例 3：
输入：nums = [-1,-2,-3,0,1]
输出：2
解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。

示例 4：
输入：nums = [-1,2]
输出：1

示例 5：
输入：nums = [1,2,3,5,-6,4,0,10]
输出：4

提示：
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
```

***首先不看题目，看数组长度，`N = 10^5`，对于这个规模的数据，`O(N^2)` 的算法可能会超时，
这题和树、二分什么的也没有关系，考虑是不是一个 `O(N)` 的算法。***

明显感觉是动态规划问题，注意状态是怎么转换的：

1. 正数乘正数还是正数，乘负数变成负数；
2. 负数乘正数还是负数，乘负数变成正数。
   
假如设 `dp[i]` 是以 `nums[i]` 结尾，乘积为正的最长子数组的长度。那么因为 `dp[i+1]` 不仅仅与 `dp[i]` 有关，
还可能由负数乘负数转化而来，这个设计不合理。

所以设 `positive[i]` 是以 `nums[i]` 结尾，乘积为正的最长子数组的长度，
又设 `negative[i]` 是以 `nums[i]` 结尾，乘积为负的最长子数组的长度。
列写正式的状态转换式：

```
if (nums[i] > 0):
    positive[i] = positive[i-1] + 1 
    negative[i] = negative[i-1] + 1
if (nums[i] < 0):
    positive[i] = negative[i-1] + 1 
    negative[i] = positive[i-1] + 1
```

除状态转换式外还需要的是初始状态，这个简单，单独判断一下就好了：

```
positive[0] = nums[0] > 0 ? 1 : 0
negative[0] = nums[0] < 0 ? 1 : 0
```

但是**先别急着写代码，有了思路之后的第一件事应该是代入用例验证一下，以防设计出错，写了半天白忙活。**
看了用例一下就发现了，还有 `nums[i] == 0` 的情况没有考虑。
以 `nums[i]` 结尾，乘积为正或负的最长子数组的长度显然都是零了。那么：

```
if (nums[i] == 0):
    positive[i] = 0
    negative[i] = 0
```

再看一下示例 2，发现不对劲：

```
nums       0 1 -2 -3 -4
positive   0 1  2  3  4
negative   0 1  2  3  4
expected: 3 found: 4
```

原因在于 `nums[0] == 0` 重置了状态，其后的 `positive[1]`、`negative[1]` 需要像初始状态一样考虑。
换句话说，当 `negative[i-1] == 0`，`nums[i]` 为正数时 `negative[i]` 还是 0，为负数时也没有
负负得正的效果，`positive[i]` 不等于 `negative[i-1] + 1`。
综上，修正状态转换式：

```
if (nums[i] > 0):
    positive[i] = positive[i-1] + 1 
    negative[i] = negative[i-1] == 0 ? 0 : negative[i-1] + 1
if (nums[i] < 0):
    positive[i] = negative[i-1] == 0 ? 0 : negative[i-1] + 1 
    negative[i] = positive[i-1] + 1
```

同时注意，这里也包含了初始状态，不需要再单独考虑。

最后注意，**状态 i 仅仅与状态 i-1 有关，所以可以对这个一维线性动态规划进行状态压缩**，仅用迭代
变量 positive, negative 代替动态规划的数组。

```
class Solution {
    public int getMaxLen(int[] nums) {
        int positive = 0, negative = 0;
        int res = 0;
        for (final int num : nums) {
            if (num == 0) {
                positive = 0;
                negative = 0;
            } else if (num > 0) {
                positive++;
                negative = negative == 0 ? 0 : negative + 1;
            } else {
                int lastNegative = negative;
                negative = positive + 1;
                positive = lastNegative == 0 ? 0 : lastNegative + 1;
            }
            res = Math.max(res, positive);
        }
        return res;
    }
}
```

# 二分搜索

![binary search 1](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-binarysearch-1.jpg)
![binary search 2](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-binarysearch-2.jpg)

几个值得注意的点分别是：

<!-- 区间为左闭右开，即 `[left, right)`。好处有三：一来分隔区间比较自然，表示为 `[left, mid)` 和 `[mid, right)`；
二来区间两端值的差正好是区间的长度，如 `[0, 4)` 的区间长度为 `4 - 0 = 4`；最后方便表示空区间，此时两端值
相等，如 `[0,0)`。 -->

1）区间为左闭右闭，即 `[left, right]`，循环内部的隐性约束是要搜索的数（如果存在的话）在当前搜索的闭区间内。

2）while **循环的条件是 `left < right` 而不是 `left <= right`**，这样循环终止时，必有 `left == right`，
使用任意一个都一样，不易出错。

3）区间长度是偶数时涉及到左右中位数的问题，比如 `[0,3]` 的中位数有 `1` 和 `2` 两个。
常见的中位数写法有三种：

| 左中位数                        | 右中位数                          |
| :------------------------------ | :-------------------------------- |
| mid = (left + right) / 2        | mid = (left + right+1) / 2        |
| mid = left + (right - left) / 2 | mid = left + (right - left + 1) / 2 |
| (left + right) >>> 1            | (left + right + 1) >>> 1          |

在默认 `left` 和 `right` 是数组索引，为自然数时，第一种写法
容易整数溢出，不考虑；第二种写法保证不会溢出；第三种写法使用的是 Java 的无符号右移，
即使加和溢出为负数了，移位后的结果仍然是正确的正中位数，这种写法看起来也比第二种清晰，推荐使用。
但是，在 `left` 和 `right` 可能为负数时，第一种使用的除 2 取商是向 0 取整的而不是向下取整的；
第三种写法会把负数移位成正数，直接就不对了；但第二种写法始终是正确的。

4）二分搜索一旦没写好很容易在区间只有两个数时进入死循环，所以判断中位数后一个边界应该在满足 1） 中的约束
的同时更加激进地缩小区间（`left = mid + 1` 或者 `right = mid - 1`）。**同时中位数应该选择更加激进的那一边的，
即 `left = mid + 1` 对应左中位数，`right = mid - 1` 对应右中位数。**

5）至于书写思路，建议先写分支逻辑，并且**先写排除中位数的逻辑分支（因为更多时候排除中位数的 `if` 条件
容易想，不过这并不绝对），另一个分支的逻辑你就不用想了，`else` 就是它的取反。再根据分支的情况
选择使用左中位数还是右中位数。**

# 马拉车算法(Manacher's Algorithm)

这个算法用于在 `O(N)` 时间内提取一个字符串中有关回文串的信息。

“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串，
单个字符，重复的字符同样是回文串。鉴于它的中心对称性，不难想到判断一个字符串是回文串的
方法是在循环内依次判断对称位置的字符是否相同。但是如果要找出一个字符串中的最长回文串，
或者计数存在的所有回文串，我们就需要在外层再枚举每一个子串，时间复杂度较高。
而马拉车算法充分利用回文串的对称性以简化计算。

以下转载自[windliang 的知乎文章《一文让你彻底明白马拉车算法》](https://zhuanlan.zhihu.com/p/70532099)

## 插入占位符

首先我们需要解决下奇数和偶数的问题，在原字符串中插入未出现的字符作占位符。例如，在每个字符间插入"#"，
并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 "^" 和 "$"，这样中心扩展的时候，
判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了，
后面进行中心扩展时情况就简化了。

```
a -> ^#a#$
aa -> ^#a#a#$
abc -> ^#a#b#c#$

设原字符串长度 n，插入 # 后长度为 n + n + 1，插入起始字符后长度为 2n + 3，必为奇数。
```

## 回文串长度

首先我们用一个数组 `P` 保存从中心扩展的回文串的最大半径，而它刚好也是去掉 "#" 的原回文串的总长度。
例如下图中下标是 6 的地方。可以看到 `P[6]` 等于 5，所以它是向左边扩展 5 个字符，相应的右边也是扩展 5 个字符，
也就是 "#c#b#c#b#c#"。而去掉 # 恢复到原来的字符串，变成 "cbcbc"，它的长度刚好也就是 5。

![manacher-1](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-1.jpg)

## 回文串位置

用 `P` 的下标 `i` 减去 `P[i]`，再除以 2 ，就是原回文串的开头下标了。

例如在上图中，我们找到 `P[i]` 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，
所以原字符串的开头下标是 `(6 - 5) / 2 = 0`。

## 求 P[i]

接下来是算法的关键了，它充分利用了回文串的对称性。

我们用 C 表示回文串的中心，用 R 表示回文串的右边半径（包含）对应的下标。所以有 `R = C + P[i]`。
C 和 R 所确定的回文串是当前循环中 R 最靠右的回文串。

让我们考虑求 `P[i]` 的时候，如下图。

用 i_mirror 表示当前需要求的第 i 个字符关于 C 对称的下标。

![manacher-2](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-2.jpg)

我们现在要求 `P[i]`，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。
i 关于 C 的对称点是 i_mirror，`P[i_mirror] = 3`，所以 `P[i]` 也等于 3 。

但是有三种情况将会造成直接赋值为 `P[i_mirror]` 是不正确的，下边一一讨论。

### 1）超出了 R

![manacher-3](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-3.jpg)

当我们要求 `P[i]` 的时候，`P[mirror] = 7`，而此时 `P[i]` 并不等于 7 。为什么呢，因为我们从 i 开始往后数 7 个，
等于 22 ，已经超过了最右的 R 。此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 `P[i]` 至少等于 `R - i = 20 - 15 = 5`。
会不会更大呢，我们只需要比较 `T[R+1]` 和 `T[R+1]` 关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。

### 2）`P[i_mirror]` 遇到了原字符串的左边界

![manacher-4](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-4.jpg)

此时 `P[i_mirror] = 1`，但是 `P[i]` 赋值成 1 是不正确的。出现这种情况的原因是 `P[i_mirror]` 在扩展的时候首先是 `"#" == "#"`，
之后遇到了 "^" 和另一个字符比较，也就是到了边界，才终止循环的。而 `P[i]` 并没有遇到边界，
所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。

### 3）i 等于了 R

此时我们先把 `P[i]` 赋值为 0 ，然后通过中心扩展法一步一步扩展就行了。

## C 和 R 的更新

就这样一步一步的求出每个 `P[i]`，当求出的 `P[i]` 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。
因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。

![manacher-4](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-4.jpg)

此时的 `P[i]` 求出来将会是 3 ，`P[i]` 对应的右边界将是 `10 + 3 = 13`。所以大于当前的 R ，我们需要把 C 更新成 i 的值，
也就是 10 ，R 更新成 13。继续下边的循环。

## 代码模板

```
private String preprocess(String s) {
    if (s.length() == 0) {
        return "^$";
    }

    var str = new StringBuilder(s.length() * 2 + 3);
    str.append("^"); // prefix
    for (var c : s.toCharArray()) {
        str.append("#");
        str.append(c);
    }
    str.append("#$");
    return str.toString();
}

public xxx palindrome(String s) {
    String T = preprocess(s);
    int[] P = new int[T.length()];
    int C = 0, R = 0; // init

    // 马拉车核心代码
    for (int i = 1; i < T.length() - 1; i++) { // i 为 0、T.length()-1 对应前缀，后缀，P[i] 必为 0 
        int i_mirror = 2 * C - i;
        // 简洁版这么写
        // P[i] = R > i ? Math.min(R - i, P[i_mirror]) : 0;
        if (R > i) {
            P[i] = Math.min(R - i, P[i_mirror]); // 防止超出 R
        } else { // R == i 或者循环开始时 R < i
            P[i] = 0; 
        }

        // 碰到之前讲的三种情况时候，需要利用中心扩展法
        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {
            P[i]++;
        }

        // 判断是否需要更新 R
        if (i + P[i] > R) {
            C = i;
            R = i + P[i];
        }
    }

    // 1. 求最长回文子串
    int maxLen = 0;
    int centerIndex = 0;
    for (int i = 1; i < n - 1; i++) { // 找出 P 的最大值
        if (P[i] > maxLen) {
            maxLen = P[i];
            centerIndex = i;
        }
    }
    int start = (centerIndex - maxLen) / 2; // 最开始讲的求原字符串下标
    return s.substring(start, start + maxLen);

    // 2. 求回文子串数目
    // 设 a = P[i]，其代表 i 对应的最长回文串的长度，
    // 而长为 a 的回文串又共计包含 (a + 1) / 2 个回文子串，
    // 比如长为 5 的回文串包含长为 5，3，1 的回文子串，
    // 长为 4 的回文串包含长为 4，2 的回文子串。
    return Arrays.stream(P).map(a -> (a + 1) / 2).sum();

}
```

## 回文串的其他算法与性质

马拉车算法是专门用于解决回文串问题的算法，但不是每个回文串的问题用马拉车算法解决都简单。
比如，可以使用动态规划找出字符串中的回文子串。

```
class Solution {
    // 最长回文子串
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n]; 
        String ans = "";

        // 考虑状态转移公式，并以此确定扫描方向
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (j == i) {
                    dp[i][j] = true;
                } else if (j == i + 1) {
                    dp[i][j] = (s.charAt(j) == s.charAt(i));
                } else {
                    dp[i][j] = ((s.charAt(j) == s.charAt(i)) && dp[i + 1][j - 1]);
                }

                if (dp[i][j] && (j - i + 1 > ans.length())) {
                    ans = s.substring(i, j + 1);
                }
            }
        }

        // 不仅仅可以用来找最长回文子串，事实上 dp 数组内存储着所有的回文子串
        return ans;
    }
}
```

再考虑一下[这个问题](https://leetcode-cn.com/problems/palindrome-partitioning)：

```
131. 分割回文串

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
返回 s 所有可能的分割方案。

示例:
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```

通过 DFS 搜索求解是最直观、最简单的思路。而使用动态规划寻找所有回文串的预处理可以把
判断枚举到的字符串是不是回文串的操作变成 `O(1)` 操作。思考一下使用马拉车算法作预处理要怎么写，以及可不可以
不进行字符串的 DFS 搜索，直接在马拉车的结果基础上进行搜索。

有的问题就完全用不到马拉车算法了。**一般回文串问题经常与区间动态规划、双指针等有关。**
考虑动态规划问题 [516.最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/):

```
给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1:
输入:
"bbbab"
输出:
4
一个可能的最长回文子序列为 "bbbb"。

示例 2:
输入:
"cbbd"
输出:
2
一个可能的最长回文子序列为 "bb"。

提示：
1 <= s.length <= 1000
s 只包含小写英文字母

设 dp[i][j] 表示 s 的第 i 个字符到第 j 个字符组成的子串中，最长的回文序列的长度，思考状态转换公式是什么。
```

另外推荐 LeetCode 上的[回文串练习](https://leetcode-cn.com/problemset/all/?search=%E5%9B%9E%E6%96%87%E4%B8%B2)，
尤其推荐这几题：

- [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)
- [336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)
- [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)
- [1278. 分割回文串 III](https://leetcode-cn.com/problems/palindrome-partitioning-iii/)
- [1312. 让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)
- [866. 回文素数](https://leetcode-cn.com/problems/prime-palindrome/)
- [906. 超级回文数](https://leetcode-cn.com/problems/super-palindromes/)

前两题利用了从回文串对称性延伸的性质：

假设存在两个字符串 `s1` 和 `s2`，`s1` 可与 `s2` 拼接成一个回文串，则必有：

- 若 `s1` 和 `s2` 长度相等，则 `s1.reverse == s2`;
- 若 `s1` 和 `s2` 长度不等，且设 `s1` 是较长串，`s1 = t1 + t2`，则有
`t1` 是回文串而 `t2.reverse == s2`（此时 `s2 + s1` 是回文串）或者 `t2` 是回文串而 `t1.reverse == s2`（此时 `s1 + s2` 是回文串）

最后两题涉及了回文串的枚举方法：枚举“回文根”作对称。比如：回文根“123”对应“123321”和“12321”，回文根“1”对应“1”和“11”。

# 并查集

在[这儿](https://www.yuque.com/liweiwei1419/algo/ltd86x)有非常全面的并查集知识讲解。
下面借[990.等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)
这道题介绍并查集模板：

```
// 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，
// 并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
// 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 

// 示例 1：
// 输入：["a==b","b!=a"]
// 输出：false
// 解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。

// 示例 2：
// 输入：["b==a","a==b"]
// 输出：true
// 解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。

// 示例 3：
// 输入：["a==b","b==c","a==c"]
// 输出：true

// 示例 4：
// 输入：["a==b","b!=c","c==a"]
// 输出：false

// 示例 5：
// 输入：["c==c","b==d","x!=z"]
// 输出：true
//  
// 提示：
// 1 <= equations.length <= 500
// equations[i].length == 4
// equations[i][0] 和 equations[i][3] 是小写字母
// equations[i][1] 要么是 '='，要么是 '!'
// equations[i][2] 是 '='

class Solution {
    public boolean equationsPossible(String[] equations) {
        Supplier<Stream<String>> eqs = () -> Arrays.stream(equations); // note that a stream can only be used once
        var set = new UnionFindSet(26); // it's ok to set size to 26
        eqs.get().filter(s -> s.charAt(1) == '=').forEach(s -> set.union(s.charAt(0) - 'a', s.charAt(3) - 'a'));
        return eqs.get().filter(s -> s.charAt(1) == '!').noneMatch(s -> set.connected(s.charAt(0) - 'a', s.charAt(3) - 'a'));
    }

    private class UnionFindSet {
        private final int[] parent;

        UnionFindSet(int n) {
            parent = IntStream.range(0, n).toArray();
        }

        // 彻底路径压缩
        int find(int a) {
            if (parent[a] != a) { // I'm not the root
                parent[a] = find(parent[a]); // set my parent to the root
            }
            return parent[a]; // return the root
        }

        // 或者隔代路径压缩
        // int find(int p) {
        //     while (p != parent[p]) {
        //         parent[p] = parent[parent[p]];
        //         p = parent[p];
        //     }
        //     return p;
        // }

        void union(int a, int b) {
            parent[find(a)] = find(b);
        }

        boolean connected(int a, int b) {
            return find(a) == find(b);
        }
    }
}
```

# 数学与数字

```
// 把给定的数字分成指定位数的数组
// INPUT: 14458, num[5]
// OUTPUT: num[5]{8,5,4,4,1}
public static void numToArray(int number, int[] num) {
    for (int i = 0; i < num.length; i++) {
        num[i] = number % 10;
        number /= 10;
    }
}

// 把给定的数组变成数字
// INPUT: num[5]{8,5,4,4,1}
// OUTPUT: 14458, num[5]
public static int arrayToNum(int[] num) {
    int n;

    for (int i = 0; i < num.length; i++) {
        n = n * 10 + num[i];
    }

    return n;
}

// 求a,b的最小公约数，利用辗转相除法，其实是利用定理 gcd(a, b) == gcd(b, a % b)
// 由此可以递归，边界是 gcd(a, 0) == a
public static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }

    return gcd(b, a % 10);
}

// 求a,b的最小公倍数，利用上面求到的最小公约数 d，
// lcm = (a * b) / d，为了防止 a*b 溢出，写成 (a / d) * d
public static int lcm(int a, int b) {
    return a / gcd(a, b) * b;

}

// 分数，保存分子分母，方便起见，使用假分数
class Fraction {
    int up, down;

    // 化简，使其满足三个条件：
    // 1. 分母始终为正数
    // 2. 如果分子是0，则分母是1
    // 3. 分子分母最小公约数是1
    public void reduction() {
        if (down < 0) {
            down = -down;
            up = -up;
        }

        if (up == 0) {
            down = 1;
        } else {
            // 记得取绝对值
            int d = gcd(Math.abs(up), Math.abs(down));
            up /= d;
            down /= d;
        }
    }

    // 分数的除法，加减乘同理，返回自己，方便链式调用
    public Fraction dividedBy(Fraction f) {
        up *= f.down;
        down *= f.up;
        // 结果记得化简
        reduction();

        return this;
    }

    // 输出分三种情况：
    // 1. 如果分母为1，则是整数，只输出分子 
    // 2. 如果分子绝对值大于分母，则是假分数，可以选择按带分数形式输出
    // 3. 其他情况，是真分数直接输出
    public void print() {
        reduction();  // 记得先化简

        if (down == 1) {
            System.out.print(up);
        } else if (Math.abs(up) > down) {
            // 注意比较和输出分子时都要取绝对值
            System.out.printf("%d %d/%d", up / down, Math.abs(up) % down, down);
        } else {
            System.out.printf("%d/%d", up, down);
        }
    }
}

// 判断一个数是不是素数，注意1既不是素数又不是合数，因子只需要判断到这个数的开方
public static boolean isPrime(int n) {
    if (n <= 1) {
        return false;
    }

    int sqr = (int) Math.sqrt(n * 1.0);// 变量外提，强制类型转换，以优化循环速度
    for (int i = 2; i <= sqr; i++) { // 从2开始判断，注意i<=sqr含有等号
        if (n % i == 0) {
            return false;
        }
    }

    // 实践中，如果n比较小（10的9次方之内），可以简单的这样写
    // for(int i = 2; i * i <=n; i++){
    //     if(n % i == 0)
    //         return false;
    // }

    return true;
}

// 获取一张直到给定数的素数表，从小数字开始，每发现一个素数，就向后筛去这个素数的整倍数
public static ArrayList<Integer> getPrimeList(int max) {
    // 带标记表的方法
    boolean[] mark = new boolean[max + 1]; // 偏移1个单位，使索引与数字对应
    ArrayList<Integer> primes = new ArrayList<>();

    for (int i = 2; i <= max; i++) { // 从2开始
        if (!mark[i]) { // 注意，标记为false即是素数，否则不做任何处理
            primes.add(i);

            for (int j = i + 1; j <= max; j += i) { // 从i+1开始向后筛去整倍数，步进是i
                mark[j] = true;
            }
        }
    }

    return primes;
}
```

---

> 参考：[李威威的简书博客](https://www.jianshu.com/p/b6ad653fb2e1)
> 最后附上 GitHub：<https://github.com/gonearewe>
