---
layout: post
title: 常用算法模板
subtitle: 算法练习笔记
date: 2020-08-26
author: John Mactavish
header-img: img/post-bg-yellowstone-hotwater.jpg
catalog: true
tags:
  - 算法
---

# DFS

模板如下：

```
void dfs(int 当前状态)
{
      if(当前状态为边界状态)
      {
        记录或输出
        return;
      }
      for(每一个子状态)		//横向遍历解答树所有子节点
      {
            修改了全局变量
            if(子状态满足约束条件)
            {
              dfs(子状态)
            }
            恢复全局变量//回溯部分
      }
}
```

实例：

```
# 题目：输出一个数组中所有元素的全排列

def full_permutation(arr):
    visited = [1] * len(arr)
    temp = arr[:] # 浅拷贝
    result = []
    def dfs(position):
        if position == len(arr):
            result.append(temp[:])  # 浅拷贝，否则result中所有行都一样
            return
        for index in range(len(arr)):
            if visited[index]:
                temp[position] = arr[index]
                visited[index] = 0
                dfs(position+1)
                visited[index] = 1
    dfs(0)
    return result

print(full_permutation([1,2,3]))
# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]


// 题目：给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

// 示例:
// 输入: [4, 6, 7, 7]
// 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

// 说明:
// 给定数组的长度不会超过15。
// 数组中的整数范围是 [-100,100]。
// 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

import java.util.ArrayList;
import java.util.List;

class Solution { // 递归枚举
    private List<List<Integer>> res = new ArrayList<>();
    private int[] nums;

    public List<List<Integer>> findSubsequences(int[] nums) {
        this.nums = nums;
        backtrace(new ArrayList<Integer>(), 0, Integer.MIN_VALUE);
        return res;
    }

    private void backtrace(List<Integer> path, int cur, int last) {
        if (cur >= nums.length) {
            if (path.size() >= 2) {
                res.add(new ArrayList<>(path));
            }
            return;
        }

        if (last != nums[cur]) { // last 用于防止重复枚举
            // 两个相同元素有四种情况：
            //     前者被选择，后者被选择
            //     前者被选择，后者不被选择
            //     前者不被选择，后者被选择
            //     前者不被选择，后者不被选择
            // 第二种情况和第三种情况是重复的，我们令“前者被选择时后者必被选择”，舍弃了第二种
            backtrace(path, cur + 1, last);
        }
        if (nums[cur] >= last) {
            path.add(nums[cur]);
            backtrace(path, cur + 1, nums[cur]);
            path.remove(path.size() - 1);
        }
    }
}
```

# 动态规划

```
给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。

一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。

请你返回乘积为正数的最长子数组长度。

示例  1：
输入：nums = [1,-2,-3,4]
输出：4
解释：数组本身乘积就是正数，值为 24 。

示例 2：
输入：nums = [0,1,-2,-3,-4]
输出：3
解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。

示例 3：
输入：nums = [-1,-2,-3,0,1]
输出：2
解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。

示例 4：
输入：nums = [-1,2]
输出：1

示例 5：
输入：nums = [1,2,3,5,-6,4,0,10]
输出：4

提示：
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
```

***首先不看题目，看数组长度，`N = 10^5`，对于这个规模的数据，`O(N^2)` 的算法可能会超时，
这题和树、二分什么的也没有关系，考虑是不是一个 `O(N)` 的算法。***

明显感觉是动态规划问题，注意状态是怎么转换的：

1. 正数乘正数还是正数，乘负数变成负数；
2. 负数乘正数还是负数，乘负数变成正数。
   
假如设 `dp[i]` 是以 `nums[i]` 结尾，乘积为正的最长子数组的长度。那么因为 `dp[i+1]` 不仅仅与 `dp[i]` 有关，
还可能由负数乘负数转化而来，这个设计不合理。

所以设 `positive[i]` 是以 `nums[i]` 结尾，乘积为正的最长子数组的长度，
又设 `negative[i]` 是以 `nums[i]` 结尾，乘积为负的最长子数组的长度。
列写正式的状态转换式：

```
if (nums[i] > 0):
    positive[i] = positive[i-1] + 1 
    negative[i] = negative[i-1] + 1
if (nums[i] < 0):
    positive[i] = negative[i-1] + 1 
    negative[i] = positive[i-1] + 1
```

除状态转换式外还需要的是初始状态，这个简单，单独判断一下就好了：

```
positive[0] = nums[0] > 0 ? 1 : 0
negative[0] = nums[0] < 0 ? 1 : 0
```

但是**先别急着写代码，有了思路之后的第一件事应该是代入用例验证一下，以防设计出错，写了半天白忙活。**
看了用例一下就发现了，还有 `nums[i] == 0` 的情况没有考虑。
以 `nums[i]` 结尾，乘积为正或负的最长子数组的长度显然都是零了。那么：

```
if (nums[i] == 0):
    positive[i] = 0
    negative[i] = 0
```

再看一下示例 2，发现不对劲：

```
nums       0 1 -2 -3 -4
positive   0 1  2  3  4
negative   0 1  2  3  4
expected: 3 found: 4
```

原因在于 `nums[0] == 0` 重置了状态，其后的 `positive[1]`、`negative[1]` 需要像初始状态一样考虑。
换句话说，当 `negative[i-1] == 0`，`nums[i]` 为正数时 `negative[i]` 还是 0，为负数时也没有
负负得正的效果，`positive[i]` 不等于 `negative[i-1] + 1`。
综上，修正状态转换式：

```
if (nums[i] > 0):
    positive[i] = positive[i-1] + 1 
    negative[i] = negative[i-1] == 0 ? 0 : negative[i-1] + 1
if (nums[i] < 0):
    positive[i] = negative[i-1] == 0 ? 0 : negative[i-1] + 1 
    negative[i] = positive[i-1] + 1
```

同时注意，这里也包含了初始状态，不需要再单独考虑。

最后注意，**状态 i 仅仅与状态 i-1 有关，所以可以对这个一维线性动态规划进行状态压缩**，仅用迭代
变量 positive, negative 代替动态规划的数组。

```
class Solution {
    public int getMaxLen(int[] nums) {
        int positive = 0, negative = 0;
        int res = 0;
        for (final int num : nums) {
            if (num == 0) {
                positive = 0;
                negative = 0;
            } else if (num > 0) {
                positive++;
                negative = negative == 0 ? 0 : negative + 1;
            } else {
                int lastNegative = negative;
                negative = positive + 1;
                positive = lastNegative == 0 ? 0 : lastNegative + 1;
            }
            res = Math.max(res, positive);
        }
        return res;
    }
}
```

# 二分搜索

![binary search 1](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-binarysearch-1.jpg)
![binary search 2](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-binarysearch-2.jpg)

几个值得注意的点分别是：

<!-- 区间为左闭右开，即 `[left, right)`。好处有三：一来分隔区间比较自然，表示为 `[left, mid)` 和 `[mid, right)`；
二来区间两端值的差正好是区间的长度，如 `[0, 4)` 的区间长度为 `4 - 0 = 4`；最后方便表示空区间，此时两端值
相等，如 `[0,0)`。 -->

1）区间为左闭右闭，即 `[left, right]`，循环内部的隐性约束是要搜索的数（如果存在的话）在当前搜索的闭区间内。

2）while **循环的条件是 `left < right` 而不是 `left <= right`**，这样循环终止时，必有 `left == right`，
使用任意一个都一样，不易出错。

3）区间长度是偶数时涉及到左右中位数的问题，比如 `[0,3]` 的中位数有 `1` 和 `2` 两个。
常见的中位数写法有三种：

| 左中位数                        | 右中位数                          |
| :------------------------------ | :-------------------------------- |
| mid = (left + right) / 2        | mid = (left + right+1) / 2        |
| mid = left + (right - left) / 2 | mid = left + (right - left + 1) / 2 |
| (left + right) >>> 1            | (left + right + 1) >>> 1          |

在默认 `left` 和 `right` 是数组索引，为自然数时，第一种写法
容易整数溢出，不考虑；第二种写法保证不会溢出；第三种写法使用的是 Java 的无符号右移，
即使加和溢出为负数了，移位后的结果仍然是正确的正中位数，这种写法看起来也比第二种清晰，推荐使用。
但是，在 `left` 和 `right` 可能为负数时，第一种使用的除 2 取商是向 0 取整的而不是向下取整的；
第三种写法会把负数移位成正数，直接就不对了；但第二种写法始终是正确的。

4）二分搜索一旦没写好很容易在区间只有两个数时进入死循环，所以判断中位数后一个边界应该在满足 1） 中的约束
的同时更加激进地缩小区间（`left = mid + 1` 或者 `right = mid - 1`）。**同时中位数应该选择更加激进的那一边的，
即 `left = mid + 1` 对应左中位数，`right = mid - 1` 对应右中位数。**

5）至于书写思路，建议先写分支逻辑，并且**先写排除中位数的逻辑分支（因为更多时候排除中位数的 `if` 条件
容易想，不过这并不绝对），另一个分支的逻辑你就不用想了，`else` 就是它的取反。再根据分支的情况
选择使用左中位数还是右中位数。**

# 数学与数字

```
// 把给定的数字分成指定位数的数组
// INPUT: 14458, num[5]
// OUTPUT: num[5]{8,5,4,4,1}
public static void numToArray(int number, int[] num) {
    for (int i = 0; i < num.length; i++) {
        num[i] = number % 10;
        number /= 10;
    }
}

// 把给定的数组变成数字
// INPUT: num[5]{8,5,4,4,1}
// OUTPUT: 14458, num[5]
public static int arrayToNum(int[] num) {
    int n;

    for (int i = 0; i < num.length; i++) {
        n = n * 10 + num[i];
    }

    return n;
}

// 求a,b的最小公约数，利用辗转相除法，其实是利用定理 gcd(a, b) == gcd(b, a % b)
// 由此可以递归，边界是 gcd(a, 0) == a
public static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }

    return gcd(b, a % 10);
}

// 求a,b的最小公倍数，利用上面求到的最小公约数 d，
// lcm = (a * b) / d，为了防止 a*b 溢出，写成 (a / d) * d
public static int lcm(int a, int b) {
    return a / gcd(a, b) * b;

}

// 分数，保存分子分母，方便起见，使用假分数
class Fraction {
    int up, down;

    // 化简，使其满足三个条件：
    // 1. 分母始终为正数
    // 2. 如果分子是0，则分母是1
    // 3. 分子分母最小公约数是1
    public void reduction() {
        if (down < 0) {
            down = -down;
            up = -up;
        }

        if (up == 0) {
            down = 1;
        } else {
            // 记得取绝对值
            int d = gcd(Math.abs(up), Math.abs(down));
            up /= d;
            down /= d;
        }
    }

    // 分数的除法，加减乘同理，返回自己，方便链式调用
    public Fraction dividedBy(Fraction f) {
        up *= f.down;
        down *= f.up;
        // 结果记得化简
        reduction();

        return this;
    }

    // 输出分三种情况：
    // 1. 如果分母为1，则是整数，只输出分子 
    // 2. 如果分子绝对值大于分母，则是假分数，可以选择按带分数形式输出
    // 3. 其他情况，是真分数直接输出
    public void print() {
        reduction();  // 记得先化简

        if (down == 1) {
            System.out.print(up);
        } else if (Math.abs(up) > down) {
            // 注意比较和输出分子时都要取绝对值
            System.out.printf("%d %d/%d", up / down, Math.abs(up) % down, down);
        } else {
            System.out.printf("%d/%d", up, down);
        }
    }
}

// 判断一个数是不是素数，注意1既不是素数又不是合数，因子只需要判断到这个数的开方
public static boolean isPrime(int n) {
    if (n <= 1) {
        return false;
    }

    int sqr = (int) Math.sqrt(n * 1.0);// 变量外提，强制类型转换，以优化循环速度
    for (int i = 2; i <= sqr; i++) { // 从2开始判断，注意i<=sqr含有等号
        if (n % i == 0) {
            return false;
        }
    }

    // 实践中，如果n比较小（10的9次方之内），可以简单的这样写
    // for(int i = 2; i * i <=n; i++){
    //     if(n % i == 0)
    //         return false;
    // }

    return true;
}

// 获取一张直到给定数的素数表，从小数字开始，每发现一个素数，就向后筛去这个素数的整倍数
public static ArrayList<Integer> getPrimeList(int max) {
    // 带标记表的方法
    boolean[] mark = new boolean[max + 1]; // 偏移1个单位，使索引与数字对应
    ArrayList<Integer> primes = new ArrayList<>();

    for (int i = 2; i <= max; i++) { // 从2开始
        if (!mark[i]) { // 注意，标记为false即是素数，否则不做任何处理
            primes.add(i);

            for (int j = i + 1; j <= max; j += i) { // 从i+1开始向后筛去整倍数，步进是i
                mark[j] = true;
            }
        }
    }

    return primes;
}
```

---

> 参考：[李威威的简书博客](https://www.jianshu.com/p/b6ad653fb2e1)
> 最后附上 GitHub：<https://github.com/gonearewe>
