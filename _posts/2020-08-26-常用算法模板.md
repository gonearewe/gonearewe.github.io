---
layout: post
title: 常用算法模板
subtitle: 算法练习笔记
date: 2020-08-26
author: John Mactavish
header-img: img/post-bg-yellowstone-hotwater.jpg
catalog: true
tags:
  - 算法
---

# DFS

模板如下：

```
void dfs(int 当前状态)
{
      if(当前状态为边界状态)
      {
        记录或输出
        return;
      }
      for(每一个子状态)		//横向遍历解答树所有子节点
      {
            修改了全局变量
            if(子状态满足约束条件)
            {
              dfs(子状态)
            }
            恢复全局变量//回溯部分
      }
}
```

实例：

```
# 题目：输出一个数组中所有元素的全排列

def full_permutation(arr):
    visited = [1] * len(arr)
    temp = arr[:] # 浅拷贝
    result = []
    def dfs(position):
        if position == len(arr):
            result.append(temp[:])  # 浅拷贝，否则result中所有行都一样
            return
        for index in range(len(arr)): # range all possible paths downside
            if visited[index]:
                temp[position] = arr[index]
                visited[index] = 0
                dfs(position+1)
                visited[index] = 1
    dfs(0)
    return result

print(full_permutation([1,2,3]))
# [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]


// 题目：给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

// 示例:
// 输入: [4, 6, 7, 7]
// 输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]

// 说明:
// 给定数组的长度不会超过15。
// 数组中的整数范围是 [-100,100]。
// 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

import java.util.ArrayList;
import java.util.List;

class Solution { // 递归枚举
    private List<List<Integer>> res = new ArrayList<>();
    private int[] nums;

    public List<List<Integer>> findSubsequences(int[] nums) {
        this.nums = nums;
        backtrace(new ArrayList<Integer>(), 0, Integer.MIN_VALUE);
        return res;
    }

    private void backtrace(List<Integer> path, int cur, int last) {
        if (cur >= nums.length) {
            if (path.size() >= 2) {
                res.add(new ArrayList<>(path)); // note to copy `path`
            }
            return;
        }

        if (last != nums[cur]) { // last 用于防止重复枚举
            // 两个相同元素有四种情况：
            //     前者被选择，后者被选择
            //     前者被选择，后者不被选择
            //     前者不被选择，后者被选择
            //     前者不被选择，后者不被选择
            // 第二种情况和第三种情况是重复的，我们令“前者被选择时后者必被选择”，舍弃了第二种
            backtrace(path, cur + 1, last);
        }
        if (nums[cur] >= last) {
            path.add(nums[cur]);
            backtrace(path, cur + 1, nums[cur]);
            path.remove(path.size() - 1); // `path` is reused throughout the whole DFS
        }
    }
}
```

# 动态规划




数字三角形模型 最长上升子序列模型 背包模型 状态机模型 状态压缩DP 区间DP 树形DP 数位DP 单调队列优化DP 斜率优化DP

## 线性 DP

```
给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。

一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。

请你返回乘积为正数的最长子数组长度。

示例  1：
输入：nums = [1,-2,-3,4]
输出：4
解释：数组本身乘积就是正数，值为 24 。

示例 2：
输入：nums = [0,1,-2,-3,-4]
输出：3
解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。

示例 3：
输入：nums = [-1,-2,-3,0,1]
输出：2
解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。

示例 4：
输入：nums = [-1,2]
输出：1

示例 5：
输入：nums = [1,2,3,5,-6,4,0,10]
输出：4

提示：
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
```

***首先不看题目，看数组长度，`N = 10^5`，对于这个规模的数据，`O(N^2)` 的算法可能会超时，
这题和树、二分什么的也没有关系，考虑是不是一个 `O(N)` 的算法。***

明显感觉是动态规划问题，注意状态是怎么转换的：

1. 正数乘正数还是正数，乘负数变成负数；
2. 负数乘正数还是负数，乘负数变成正数。
   
假如设 `dp[i]` 是以 `nums[i]` 结尾，乘积为正的最长子数组的长度。那么因为 `dp[i+1]` 不仅仅与 `dp[i]` 有关，
还可能由负数乘负数转化而来，这个设计不合理。

所以设 `positive[i]` 是以 `nums[i]` 结尾，乘积为正的最长子数组的长度，
又设 `negative[i]` 是以 `nums[i]` 结尾，乘积为负的最长子数组的长度。
列写正式的状态转换式：

```
if (nums[i] > 0):
    positive[i] = positive[i-1] + 1 
    negative[i] = negative[i-1] + 1
if (nums[i] < 0):
    positive[i] = negative[i-1] + 1 
    negative[i] = positive[i-1] + 1
```

除状态转换式外还需要的是初始状态，这个简单，单独判断一下就好了：

```
positive[0] = nums[0] > 0 ? 1 : 0
negative[0] = nums[0] < 0 ? 1 : 0
```

但是**先别急着写代码，有了思路之后的第一件事应该是代入用例验证一下，以防设计出错，写了半天白忙活。**
看了用例一下就发现了，还有 `nums[i] == 0` 的情况没有考虑。
以 `nums[i]` 结尾，乘积为正或负的最长子数组的长度显然都是零了。那么：

```
if (nums[i] == 0):
    positive[i] = 0
    negative[i] = 0
```

再看一下示例 2，发现不对劲：

```
nums       0 1 -2 -3 -4
positive   0 1  2  3  4
negative   0 1  2  3  4
expected: 3 found: 4
```

原因在于 `nums[0] == 0` 重置了状态，其后的 `positive[1]`、`negative[1]` 需要像初始状态一样考虑。
换句话说，当 `negative[i-1] == 0`，`nums[i]` 为正数时 `negative[i]` 还是 0，为负数时也没有
负负得正的效果，`positive[i]` 不等于 `negative[i-1] + 1`。
综上，修正状态转换式：

```
if (nums[i] > 0):
    positive[i] = positive[i-1] + 1 
    negative[i] = negative[i-1] == 0 ? 0 : negative[i-1] + 1
if (nums[i] < 0):
    positive[i] = negative[i-1] == 0 ? 0 : negative[i-1] + 1 
    negative[i] = positive[i-1] + 1
```

同时注意，这里也包含了初始状态，不需要再单独考虑。

最后注意，**状态 i 仅仅与状态 i-1 有关，所以可以对这个一维线性动态规划进行状态压缩**，仅用迭代
变量 positive, negative 代替动态规划的数组。

```
class Solution {
    public int getMaxLen(int[] nums) {
        int positive = 0, negative = 0;
        int res = 0;
        for (final int num : nums) {
            if (num == 0) {
                positive = 0;
                negative = 0;
            } else if (num > 0) {
                positive++;
                negative = negative == 0 ? 0 : negative + 1;
            } else {
                int lastNegative = negative;
                negative = positive + 1;
                positive = lastNegative == 0 ? 0 : lastNegative + 1;
            }
            res = Math.max(res, positive);
        }
        return res;
    }
}
```

## 背包 DP

背包问题一般这样描述：有 N 种物品和一个容量为 V 的背包。第 i 种物品的费用是 `c[i]`，
价值是 `w[i]`。求解将哪些物品装入背包可使价值总和最大。如果每种物品仅有一件，可选择放或不放，那么
就是 ***0-1 背包问题***；如果每种物品都有无限件可用，那么就是***完全背包问题***。

先考虑每种物品仅有一件的情况。
一般这样定义状态：`dp[i][v]` 表示前 i 种物品恰放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是：

> dp[i][v] = f{dp[i-1][v],dp[i-1][v-c[i]]+w[i]} // f 函数在这里是 max

“将前 i 种物品放入容量为 v 的背包中”这个子问题，若只考虑第 i 种物品的策略（放或不放），
那么就可以转化为一个只牵扯前 i-1 种物品的问题。如果不放第 i 种物品，
那么问题就转化为“前 i-1 种物品放入容量为 v 的背包中”，价值为 `dp[i-1][v]`；如果放第 i 种物品，
那么问题就转化为“前 i-1 种物品放入剩下的容量为 `v-c[i]` 的背包中”，
此时能获得的最大价值就是 `dp[i-1][v-c[i]]` 再加上通过放入第 i 种物品获得的价值 `w[i]`。

注意状态转移方程中计算 `dp[i][v]` 时只使用到了上一层正上方（`dp[i-1][v]`）和左边（`dp[i-1][v-c[i]]`）的状态，
因此我们可以在实现时压缩状态数组：

```
for i=1..N
    for v=V..0
        if v>=c[i]
            dp[v]=f{dp[v],dp[v-c[i]]+w[i]}
        else
            dp[v]=f{dp[v]}
```

注意内部循环从 V 到 0 进行，这样保证了 `dp[v-c[i]]` 访问的是上一层的状态。
`v < c[i]` 时当前状态只可能从上一层正上方迁移而来，在压缩状态数组的实现中刚好什么都不需要做，
因此我们事实上这样写代码：

```
for i=1..N
    for v=V..c[i] // 逆序
        dp[v]=f{dp[v],dp[v-c[i]]+w[i]}
```

接下来考虑每种物品有无限件的情况。那么状态转移方程就变成：

> dp[i][v] = f{dp[i-1][v-k\*c[i]]+k\*w[i] \| 0<=k\*c[i]<=v}

事实上，它等价于：

> dp[i][v] = f{dp[i-1][v],dp[i][v-c[i]]+w[i]}

注意这里状态转移方程中计算 `dp[i][v]` 时使用到了上一层正上方（`dp[i-1][v]`）和当前层左边（`dp[i][v-c[i]]`）的状态，
因此我们用压缩状态数组实现时内部循环应当改为顺序（从 `c[i]` 到 V）以保证 `dp[v-c[i]]` 访问的是当前层的状态：

```
for i=1..N
    for v=c[i]..V // 顺序
        dp[v]=f{dp[v],dp[v-c[i]]+w[i]}
```

这样计算的结果中，选择的物品是无序的，即方案 `[1,1,3]` 与方案 `[3,1,1]` 被认为是同一种。
如果碰到了 [377.组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/) 这样的题目，
要求区分组合 `(1,1,3)` 与 `(3,1,1)` 等，需要修改状态转移方程为：

> dp[i][v] = f{dp[i-1][v],dp[N][v-c[i]]+w[i]} // f 函数在这里是 sum

因为其中的 `dp[N][v-c[i]]` 表示“将所有种类物品放入容量为 `v-c[i]` 的背包中的组合数”。
下面讨论实现：因为 `dp[i][v]` 用到了左下角的值，所以 dp 矩阵扫描方式改为外层按列扫描。

```
for v=1..V // 内外循环调换顺序
    for i=1..N
        if v>=c[i]
            dp[v]=f{dp[v],dp[v-c[i]]+w[i]} // 不是矩阵转置，dp 索引还是 v
        else
            dp[v]=f{dp[v]}
```

实际的问题当然不会描述得这么明显，所以需要能根据特征识别背包问题或把问题转化为背包问题。
背包问题的特征是一系列的可选择元素（DP 的层数）、给定的有限数的约束条件（如物品总重量 W、元素的加和 S，
作为 DP 矩阵的列）和代求的不定的量（如是否有可行方案、可行方案数目、元素的加和的最值，作为 `dp[i][j]` 的值）。
有时候还需要根据方程关系进行等价变形以得到背包问题，比如下面这个问题：

```
// 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。
// 对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
// 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

// 示例：
// 输入：nums: [1, 1, 1, 1, 1], S: 3
// 输出：5
// 解释：

// -1+1+1+1+1 = 3
// +1-1+1+1+1 = 3
// +1+1-1+1+1 = 3
// +1+1+1-1+1 = 3
// +1+1+1+1-1 = 3

// 一共有5种方法让最终目标和为3。
//  
// 提示：
// 数组非空，且长度不会超过 20 。
// 初始的数组的和不会超过 1000 。
// 保证返回的最终结果能被 32 位整数存下。


// 此问题可以转化为子集划分问题
//
// 将一个集合划分成两个子集 A,B, 问满足 sum(A) - sum(B) = Target的分法有多少种
// 两端同时加上集合元素和 sum,得到 2 * sum(A) = Target + sum ==> sum(A) = (Target + sum) / 2
//
// 又已知 sum(A) = sum(B) + Target >= Target, sum = sum(A) + sum(B) >= sum(A)
// 故得预筛选条件 sum >= Target 和 (Target + sum) % 2 == 0

import java.util.Arrays;

class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = Arrays.stream(nums).sum();
        if (sum < S || (sum + S) % 2 != 0) {
            return 0;
        }

        int[] dp = new int[sum + 1];
        dp[0] = 1; // 0 元素加和为 0 有 1 种方案
        for (int num : nums) {
            for (int j = dp.length - 1; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[(sum + S) / 2];
    }
}
```

最后总结一下模板：

> dp[i][v] = f{dp[i-1][v],dp[`i-1`][v-c[i]]+w[i]} // 0-1 背包
> 
> dp[i][v] = f{dp[i-1][v],dp[`i`][v-c[i]]+w[i]} // 完全背包
> 
> dp[i][v] = f{dp[i-1][v],dp[`N`][v-c[i]]+w[i]} // 考虑物品顺序的完全背包

对于其中的 f 函数：

- 在“方案是否存在”问题中，`f = or`(布尔或)
- 在“方案有多少种”问题中，`f = sum`
- 在“最优方案”问题中，`f = best`(比如 max 或者 min)

至于具体实现中的扫描方式，根据状态转移方程很容易想出来，初始条件一般也不难，都不需要记忆。

# 二分搜索

![binary search 1](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-binarysearch-1.jpg)
![binary search 2](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-binarysearch-2.jpg)

几个值得注意的点分别是：

<!-- 区间为左闭右开，即 `[left, right)`。好处有三：一来分隔区间比较自然，表示为 `[left, mid)` 和 `[mid, right)`；
二来区间两端值的差正好是区间的长度，如 `[0, 4)` 的区间长度为 `4 - 0 = 4`；最后方便表示空区间，此时两端值
相等，如 `[0,0)`。 -->

1）区间为左闭右闭，即 `[left, right]`，循环内部的隐性约束是要搜索的数（如果存在的话）在当前搜索的闭区间内。

2）while **循环的条件是 `left < right` 而不是 `left <= right`**，这样循环终止时，必有 `left == right`，
使用任意一个都一样，不易出错。

3）区间长度是偶数时涉及到左右中位数的问题，比如 `[0,3]` 的中位数有 `1` 和 `2` 两个。
常见的中位数写法有三种：

| 左中位数                        | 右中位数                          |
| :------------------------------ | :-------------------------------- |
| mid = (left + right) / 2        | mid = (left + right+1) / 2        |
| mid = left + (right - left) / 2 | mid = left + (right - left + 1) / 2 |
| (left + right) >>> 1            | (left + right + 1) >>> 1          |

在默认 `left` 和 `right` 是数组索引，为自然数时，第一种写法
容易整数溢出，不考虑；第二种写法保证不会溢出；第三种写法使用的是 Java 的无符号右移，
即使加和溢出为负数了，移位后的结果仍然是正确的正中位数，这种写法看起来也比第二种清晰，推荐使用。
但是，在 `left` 和 `right` 可能为负数时，第一种使用的除 2 取商是向 0 取整的而不是向下取整的；
第三种写法会把负数移位成正数，直接就不对了；但第二种写法始终是正确的。

4）二分搜索一旦没写好很容易在区间只有两个数时进入死循环，所以判断中位数后一个边界应该在满足 1） 中的约束
的同时更加激进地缩小区间（`left = mid + 1` 或者 `right = mid - 1`）。**同时中位数应该选择更加激进的那一边的，
即 `left = mid + 1` 对应左中位数，`right = mid - 1` 对应右中位数。**

5）至于书写思路，建议先写分支逻辑，并且**先写排除中位数的逻辑分支（因为更多时候排除中位数的 `if` 条件
容易想，不过这并不绝对），另一个分支的逻辑你就不用想了，`else` 就是它的取反。再根据分支的情况
选择使用左中位数还是右中位数。**

二分搜索的问题不一定会问得那么明显，也可能是这样的：

- [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)
- [1552. 两球之间的磁力](https://leetcode-cn.com/problems/magnetic-force-between-two-balls/)

# 马拉车算法(Manacher's Algorithm)

这个算法用于在 `O(N)` 时间内提取一个字符串中有关回文串的信息。

“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串，
单个字符，重复的字符同样是回文串。鉴于它的中心对称性，不难想到判断一个字符串是回文串的
方法是在循环内依次判断对称位置的字符是否相同。但是如果要找出一个字符串中的最长回文串，
或者计数存在的所有回文串，我们就需要在外层再枚举每一个子串，时间复杂度较高。
而马拉车算法充分利用回文串的对称性以简化计算。

以下转载自[windliang 的知乎文章《一文让你彻底明白马拉车算法》](https://zhuanlan.zhihu.com/p/70532099)

## 插入占位符

首先我们需要解决下奇数和偶数的问题，在原字符串中插入未出现的字符作占位符。例如，在每个字符间插入"#"，
并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 "^" 和 "$"，这样中心扩展的时候，
判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了，
后面进行中心扩展时情况就简化了。

```
a -> ^#a#$
aa -> ^#a#a#$
abc -> ^#a#b#c#$

设原字符串长度 n，插入 # 后长度为 n + n + 1，插入起始字符后长度为 2n + 3，必为奇数。
```

## 回文串长度

首先我们用一个数组 `P` 保存从中心扩展的回文串的最大半径，而它刚好也是去掉 "#" 的原回文串的总长度。
例如下图中下标是 6 的地方。可以看到 `P[6]` 等于 5，所以它是向左边扩展 5 个字符，相应的右边也是扩展 5 个字符，
也就是 "#c#b#c#b#c#"。而去掉 # 恢复到原来的字符串，变成 "cbcbc"，它的长度刚好也就是 5。

![manacher-1](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-1.jpg)

## 回文串位置

用 `P` 的下标 `i` 减去 `P[i]`，再除以 2 ，就是原回文串的开头下标了。

例如在上图中，我们找到 `P[i]` 的最大值为 5 ，也就是回文串的最大长度是 5 ，对应的下标是 6 ，
所以原字符串的开头下标是 `(6 - 5) / 2 = 0`。

## 求 P[i]

接下来是算法的关键了，它充分利用了回文串的对称性。

我们用 C 表示回文串的中心，用 R 表示回文串的右边半径（包含）对应的下标。所以有 `R = C + P[i]`。
C 和 R 所确定的回文串是当前循环中 R 最靠右的回文串。

让我们考虑求 `P[i]` 的时候，如下图。

用 i_mirror 表示当前需要求的第 i 个字符关于 C 对称的下标。

![manacher-2](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-2.jpg)

我们现在要求 `P[i]`，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。
i 关于 C 的对称点是 i_mirror，`P[i_mirror] = 3`，所以 `P[i]` 也等于 3 。

但是有三种情况将会造成直接赋值为 `P[i_mirror]` 是不正确的，下边一一讨论。

### 1）超出了 R

![manacher-3](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-3.jpg)

当我们要求 `P[i]` 的时候，`P[mirror] = 7`，而此时 `P[i]` 并不等于 7 。为什么呢，因为我们从 i 开始往后数 7 个，
等于 22 ，已经超过了最右的 R 。此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 `P[i]` 至少等于 `R - i = 20 - 15 = 5`。
会不会更大呢，我们只需要比较 `T[R+1]` 和 `T[R+1]` 关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。

### 2）`P[i_mirror]` 遇到了原字符串的左边界

![manacher-4](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-4.jpg)

此时 `P[i_mirror] = 1`，但是 `P[i]` 赋值成 1 是不正确的。出现这种情况的原因是 `P[i_mirror]` 在扩展的时候首先是 `"#" == "#"`，
之后遇到了 "^" 和另一个字符比较，也就是到了边界，才终止循环的。而 `P[i]` 并没有遇到边界，
所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。

### 3）i 等于了 R

此时我们先把 `P[i]` 赋值为 0 ，然后通过中心扩展法一步一步扩展就行了。

## C 和 R 的更新

就这样一步一步的求出每个 `P[i]`，当求出的 `P[i]` 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。
因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。

![manacher-4](https://gonearewe.coding.net/p/blog/d/myblog/git/raw/master/img/post-2020-manacher-4.jpg)

此时的 `P[i]` 求出来将会是 3 ，`P[i]` 对应的右边界将是 `10 + 3 = 13`。所以大于当前的 R ，我们需要把 C 更新成 i 的值，
也就是 10 ，R 更新成 13。继续下边的循环。

## 代码模板

```
private String preprocess(String s) {
    if (s.length() == 0) {
        return "^$";
    }

    var str = new StringBuilder(s.length() * 2 + 3);
    str.append("^"); // prefix
    for (var c : s.toCharArray()) {
        str.append("#");
        str.append(c);
    }
    str.append("#$");
    return str.toString();
}

public xxx palindrome(String s) {
    String T = preprocess(s);
    int[] P = new int[T.length()];
    int C = 0, R = 0; // init

    // 马拉车核心代码
    for (int i = 1; i < T.length() - 1; i++) { // i 为 0、T.length()-1 对应前缀，后缀，P[i] 必为 0 
        int i_mirror = 2 * C - i;
        // 简洁版这么写
        // P[i] = R > i ? Math.min(R - i, P[i_mirror]) : 0;
        if (R > i) {
            P[i] = Math.min(R - i, P[i_mirror]); // 防止超出 R
        } else { // R == i 或者循环开始时 R < i
            P[i] = 0; 
        }

        // 碰到之前讲的三种情况时候，需要利用中心扩展法
        while (T.charAt(i + 1 + P[i]) == T.charAt(i - 1 - P[i])) {
            P[i]++;
        }

        // 判断是否需要更新 R
        if (i + P[i] > R) {
            C = i;
            R = i + P[i];
        }
    }

    // 1. 求最长回文子串
    int maxLen = 0;
    int centerIndex = 0;
    for (int i = 1; i < n - 1; i++) { // 找出 P 的最大值
        if (P[i] > maxLen) {
            maxLen = P[i];
            centerIndex = i;
        }
    }
    int start = (centerIndex - maxLen) / 2; // 最开始讲的求原字符串下标
    return s.substring(start, start + maxLen);

    // 2. 求回文子串数目
    // 设 a = P[i]，其代表 i 对应的最长回文串的长度，
    // 而长为 a 的回文串又共计包含 (a + 1) / 2 个回文子串，
    // 比如长为 5 的回文串包含长为 5，3，1 的回文子串，
    // 长为 4 的回文串包含长为 4，2 的回文子串。
    return Arrays.stream(P).map(a -> (a + 1) / 2).sum();

}
```

## 回文串的其他算法与性质

马拉车算法是专门用于解决回文串问题的算法，但不是每个回文串的问题用马拉车算法解决都简单。
比如，可以使用动态规划找出字符串中的回文子串。

```
class Solution {
    // 最长回文子串
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n]; 
        String ans = "";

        // 考虑状态转移公式，并以此确定扫描方向
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (j == i) {
                    dp[i][j] = true;
                } else if (j == i + 1) {
                    dp[i][j] = (s.charAt(j) == s.charAt(i));
                } else {
                    dp[i][j] = ((s.charAt(j) == s.charAt(i)) && dp[i + 1][j - 1]);
                }

                if (dp[i][j] && (j - i + 1 > ans.length())) {
                    ans = s.substring(i, j + 1);
                }
            }
        }

        // 不仅仅可以用来找最长回文子串，事实上 dp 数组内存储着所有的回文子串
        return ans;
    }
}
```

再考虑一下[这个问题](https://leetcode-cn.com/problems/palindrome-partitioning)：

```
131. 分割回文串

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。
返回 s 所有可能的分割方案。

示例:
输入: "aab"
输出:
[
  ["aa","b"],
  ["a","a","b"]
]
```

通过 DFS 搜索求解是最直观、最简单的思路。而使用动态规划寻找所有回文串的预处理可以把
判断枚举到的字符串是不是回文串的操作变成 `O(1)` 操作。思考一下使用马拉车算法作预处理要怎么写，以及可不可以
不进行字符串的 DFS 搜索，直接在马拉车的结果基础上进行搜索。

有的问题就完全用不到马拉车算法了。**一般回文串问题经常与区间动态规划、双指针等有关。**
考虑动态规划问题 [516.最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/):

```
给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1:
输入:
"bbbab"
输出:
4
一个可能的最长回文子序列为 "bbbb"。

示例 2:
输入:
"cbbd"
输出:
2
一个可能的最长回文子序列为 "bb"。

提示：
1 <= s.length <= 1000
s 只包含小写英文字母

设 dp[i][j] 表示 s 的第 i 个字符到第 j 个字符组成的子串中，最长的回文序列的长度，思考状态转换公式是什么。
```

另外推荐 LeetCode 上的[回文串练习](https://leetcode-cn.com/problemset/all/?search=%E5%9B%9E%E6%96%87%E4%B8%B2)，
尤其推荐这几题：

- [214. 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)
- [336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)
- [132. 分割回文串 II](https://leetcode-cn.com/problems/palindrome-partitioning-ii/)
- [1278. 分割回文串 III](https://leetcode-cn.com/problems/palindrome-partitioning-iii/)
- [1312. 让字符串成为回文串的最少插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)
- [866. 回文素数](https://leetcode-cn.com/problems/prime-palindrome/)
- [906. 超级回文数](https://leetcode-cn.com/problems/super-palindromes/)

前两题利用了从回文串对称性延伸的性质：

假设存在两个字符串 `s1` 和 `s2`，`s1` 可与 `s2` 拼接成一个回文串，则必有：

- 若 `s1` 和 `s2` 长度相等，则 `s1.reverse == s2`;
- 若 `s1` 和 `s2` 长度不等，且设 `s1` 是较长串，`s1 = t1 + t2`，则有
`t1` 是回文串而 `t2.reverse == s2`（此时 `s2 + s1` 是回文串）或者 `t2` 是回文串而 `t1.reverse == s2`（此时 `s1 + s2` 是回文串）

最后两题涉及了回文串的枚举方法：枚举“回文根”作对称。比如：回文根“123”对应“123321”和“12321”，回文根“1”对应“1”和“11”。

# 并查集

在[这儿](https://www.yuque.com/liweiwei1419/algo/ltd86x)有非常全面的并查集知识讲解。
简单来说，**它可以描述无向图的连通性，主要用于判断两个结点是否连通和计数一个图中彼此不相连的连通子图。**
具体地，它提供两种操作：查找（Find，确定某个元素处于哪个子集）和合并（Union，将两个子集合并成一个集合）。
它不保存各个连通子图内部的关系，换句话说，它把连通子图退化成了 Set。
在进行按秩合并的优化后，两个操作的时间复杂度均为 O(logN)；同时再加上路径压缩的话，
时间复杂度变成阿克曼函数（Ackermann）的逆函数（增长极慢，近似 O(1)）。
下面借[990.等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)
这道题介绍并查集模板：

```
// 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，
// 并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
// 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 

// 示例 1：
// 输入：["a==b","b!=a"]
// 输出：false
// 解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。

// 示例 2：
// 输入：["b==a","a==b"]
// 输出：true
// 解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。

// 示例 3：
// 输入：["a==b","b==c","a==c"]
// 输出：true

// 示例 4：
// 输入：["a==b","b!=c","c==a"]
// 输出：false

// 示例 5：
// 输入：["c==c","b==d","x!=z"]
// 输出：true
//  
// 提示：
// 1 <= equations.length <= 500
// equations[i].length == 4
// equations[i][0] 和 equations[i][3] 是小写字母
// equations[i][1] 要么是 '='，要么是 '!'
// equations[i][2] 是 '='

class Solution {
    public boolean equationsPossible(String[] equations) {
        Supplier<Stream<String>> eqs = () -> Arrays.stream(equations); // note that a stream can only be used once
        var set = new UnionFindSet(26); // it's ok to set size to 26
        eqs.get().filter(s -> s.charAt(1) == '=').forEach(s -> set.union(s.charAt(0) - 'a', s.charAt(3) - 'a'));
        return eqs.get().filter(s -> s.charAt(1) == '!').noneMatch(s -> set.connected(s.charAt(0) - 'a', s.charAt(3) - 'a'));
    }

    private class UnionFindSet {
        private final int[] parent;

        UnionFindSet(int n) {
            parent = IntStream.range(0, n).toArray();
        }

        // 彻底路径压缩（推荐）
        int find(int a) {
            if (parent[a] != a) { // I'm not the root
                parent[a] = find(parent[a]); // set my parent to the root
            }
            return parent[a]; // return the root
        }

        // 或者隔代路径压缩
        // int find(int p) {
        //     while (p != parent[p]) {
        //         parent[p] = parent[parent[p]];
        //         p = parent[p];
        //     }
        //     return p;
        // }

        void union(int a, int b) {
            parent[find(a)] = find(b);
        }

        boolean connected(int a, int b) {
            return find(a) == find(b);
        }
    }
}
```

上面的是最简单的并查集模板，根据实际需要可以进行一些扩展：

- 合并集合时采取[按秩合并](https://www.yuque.com/liweiwei1419/algo/yqleb2)，进一步优化操作时间复杂度
- 内部维护一个变量记录连通图的总数目（思考一下哪些地方需要作出改动）
- 让 union 返回一个布尔值指示函数这次是否真的进行了合并（若返回 false 说明本来就已经是连通的了，函数没有真的进行操作），
由此在并查集构建时动态检查[冗余连接](https://leetcode-cn.com/problems/redundant-connection/)
（其实这个扩展就相当于先调用 connected 函数再操作）
- 模板用整数表示并查集中的一个结点，并用其作为底层数组 `parent` 的索引，对于字符、矩阵坐标等形式表示的结点，可以设法映射到非离散的整数上；
**对于复杂数据结构，可以在外部使用 `Map<K,Integer>` 类型变量作为 id 分配器与映射器**，实在不行再考虑用 `Map<K,K>` 类型变量作为 `parent`
- 有的时候可能需要[带权值的并查集](https://www.yuque.com/liweiwei1419/algo/seywro)，
考虑加入一个与 `parent` 同长度的数组 `weight`，`weight[i]` 保存结点 `i` 与其根结点的关系

推荐练习：

- [765. 情侣牵手](https://leetcode-cn.com/problems/couples-holding-hands/)中的图的抽象不容易想出来
- [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)涉及到了有权图，
而且[它的求解](https://www.yuque.com/liweiwei1419/algo/seywro)可以用到外部的 id 映射器

# 图相关算法

## 最小生成树(Minimum Spanning Tree)

一个连通的**生成树**是图中的极小连通子图，它包括图中的所有顶点，并且只含尽可能少的边。这意味着对于生成树来说，
若砍去它的一条边，就会使生成树变成非连通图；若给它添加一条边，就会形成图中的一条回路。
对于一个带权连通无向图 `G=(V,E)`，生成树不同，每棵树的权（即树中所有边的权值之和）也可能不同。设 `R` 是 `G` 的所有生成树的集合，
若 `T` 为 `R` 中边的权值之和最小的那棵生成树，则 `T` 称为 `G` 的最小生成树。

最小生成树具有如下性质：

- 最小生成树不是唯一的，即最小生成树的树形不唯一，`R` 中可能有多个最小生成树。
当图中的各边权值互不相等时，G的最小生成树是唯一的。
- 虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的。
- 最小生成树的边数为顶点数减一。
- 若无向连通图 `G` 的边比顶点数小 1，即 `G` 本身就是一棵树时，`G` 的最小生成树就是它本身。

此外，构造最小生成树的多个算法基本都利用了最小生成树的这个重要性质：

> 假设 `G=（V,E）` 是一个带权连通无向图，`U` 是顶点集 `V` 的一个非空子集。
> 若 `（u，v）` 是满足条件“`u` 含于 `U`，`v` 含于 `V-U`”的边中权值最小的一条，
> 则必**存在**一棵包含边 `（u,v）` 的最小生成树。

基于该性质的两个常用的最小生成树算法是：Prim 算法和 Kruskal 算法，它们都基于贪心算法，
算法正确性的证明参考《算法导论》。

```
void prim(G,T){
	T=空集; //初始化空树
	U={w}; //添加任一顶点w
	while((V-U)!=空集){ //若树中不含全部顶点
		设（u,v）是满足条件“u 含于 U，v 含于 V-U”的边中权值最小的一条；
		T=T并{（u,v）}; //边归入树
		U=U并{v}; //顶点归入树
	}
}

void Kruskal(V,T){
	T=V; //初始化树 T,仅含顶点
	numS=n; //不连通分量数
	while(numS>1){//如果不连通分量树大于 1
		//从 E 中取出权值最小的边（v,u）
		if(v 和 u 分别属于 T 中不同的连通分量){
			T=T并{（v,u）};//将次边加入生成树
			numS--//不连通分量树减1
		}
	}
}
```

prim 解决问题 [1584. 连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/) 如下：

```
// 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。

// 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 
// 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。

// 请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。

// 示例 1：
// 输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
// 输出：20
// 解释：
// 我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。
// 注意到任意两个点之间只有唯一一条路径互相到达。

// 示例 2：
// 输入：points = [[3,12],[-2,5],[-4,1]]
// 输出：18

// 示例 3：
// 输入：points = [[0,0],[1,1],[1,0],[-1,1]]
// 输出：4

// 示例 4：
// 输入：points = [[-1000000,-1000000],[1000000,1000000]]
// 输出：4000000

// 示例 5：
// 输入：points = [[0,0]]
// 输出：0

// 提示：
// 1 <= points.length <= 1000
// -106 <= xi, yi <= 106
// 所有点 (xi, yi) 两两不同。
import scala.collection.mutable

object Solution { // Prim MST
  def minCostConnectPoints(points: Array[Array[Int]]): Int = {
    type Vertex = (Int, Int)
    type Distance = Int
    type Edge = (Vertex, Vertex, Distance)
    implicit val ord: Ordering[Edge] = Ordering.by[Edge, Int](_._3).reverse // descending order by Edge's length

    val vertices = points.map(p => (p(0), p(1))).toSet // set of all vertices
    val visited = mutable.Set[Vertex]((points(0)(0), points(0)(1))) // put the first vertex to start

    // generates the edges of one vertex whose partner is not visited
    def edgesOf(vertex: (Int, Int)): Array[Edge] = vertex match {
      case (x1, y1) =>
        (vertices diff visited map { case other@(x2, y2) =>
          (vertex, other, Math.abs(x1 - x2) + Math.abs(y1 - y2)) // first vertex stored in Edge is visited
        }).toArray
    }

    val queue = mutable.PriorityQueue[Edge](edgesOf((points(0)(0), points(0)(1))): _*)
    var cost = 0
    while (visited.size < points.length) { // until MST is generated
      var (_, vertex, distance) = queue.dequeue()
      while (visited(vertex)) { // make sure the second vertex stored in Edge is not visited
        queue.dequeue() match {
          case (_, v, l) => vertex = v; distance = l
        }
      }
      visited += vertex // one vertex in MST
      cost += distance // count as one edge in MST
      queue.enqueue(edgesOf(vertex): _*)
    }

    cost
  }
}
```

而 Kruskal 算法的实现的具体步骤一般是：

1. 把所有的边按权值升序排列
2. 创建一个空的并查集用于保存 MST 中的点
3. 依次遍历每一条边，判断它的两个点是否都已经在并查集里了（即是否在 MST 里）：
如是，则跳过；否则，把边记录入 MST，把点加入并查集

# 概率与统计

## 用 Rand7() 实现 Rand10()

如果我们有 `Rand10N()` 的话可以通过对 10 除取余很容易地实现 `Rand10()`，
所以可以自然地想到把 `Rand7()` 向更大的 rand 映射。一个朴素的想法是进行两次 `Rand7()` 然后
把结果相加或相乘得到 `rand of [2,14]` 或者 `rand of [1,49]`，但是仔细想想这样得到的数
并不在区间内均匀出现。然后我们可以想到一个一一映射操作：元组构建，即 `a op b -> (a,b)`。
元组又可以映射回整数（hash 码）：`hash of (a,b) is a*weight+b`，其中 weight 是权值，
等于元组中该位置所允许出现的数字的总数目。所以进行操作 `(Rand7() - 1) * 7 + Rand7() - 1` 即可
得到 `rand of [0,48]`，减一是为了让随机数从 0 开始并连续分布。但 `[0,48]` 不是 `[0,9]` 的整数倍，
但是没关系，我们可以消去比整数倍多出的部分，如果生成的随机数大于 39，直接**拒绝采样，重新生成**。

```
int rand10() {
    int n = (rand7() - 1) * 7 + rand7() - 1;
    if (n >= 40) {
        return rand10();
    }
    return n % 10 + 1;
}
```

进一步地，我们可以进行一些优化。利用范围外的数字构建新的 rand，以减少丢弃的值，
提高命中率从而提高随机数生成效率。

```
int rand10() {
    while(true) {
        int a = rand7();
        int b = rand7();
        int num = (a-1)*7 + b; // rand 49
        if(num <= 40) return num % 10 + 1; 
        
        a = num - 40; // rand 9
        b = rand7();
        num = (a-1)*7 + b; // rand 63
        if(num <= 60) return num % 10 + 1;
        
        a = num - 60; // rand 3
        b = rand7();
        num = (a-1)*7 + b; // rand 21
        if(num <= 20) return num % 10 + 1;
    }
}
```

## 蓄水池抽样

蓄水池抽样解决了一个这样的问题：给定一个数据流，数据流长度 N 很大（不能一次性存入内存），
且 N 直到处理完所有数据之前都不可知（比如链表形式），
请问如何在只遍历一遍数据的情况下，能够随机选取出 m 个不重复的数据（每个数被选中的概率为 m/N）。

证明可以看[这里](https://www.jianshu.com/p/7a9ea6ece2af)，代码模板如下：

```
int[] reservoir = new int[m];

// init
for (int i = 0; i < reservoir.length; i++)
{
    reservoir[i] = dataStream[i];
}

for (int i = m; i < dataStream.length; i++)
{
    // 随机获得一个[0, i]内的随机整数
    int d = rand.nextInt(i + 1);
    // 如果随机整数落在[0, m-1]范围内，则替换蓄水池中的元素
    if (d < m)
    {
        reservoir[d] = dataStream[i];
    }
}
```

模板中遍历 dataStream 时是知道长度的，实际上这样是可以直接用 `rand.nextInt(dataStream.length)` 选数的。
真实例子中 dataStream 要么是链表，要么是下面这种形式：

```
// 给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。

// 注意：
// 数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。

// 示例:

// int[] nums = new int[] {1,2,3,3,3};
// Solution solution = new Solution(nums);

// // pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。
// solution.pick(3);

// // pick(1) 应该返回 0。因为只有nums[0]等于1。
// solution.pick(1);

import java.util.Random;

class Solution { 
    private final int[] nums;
    private final Random rand = new Random();

    public Solution(int[] nums) {
        this.nums = nums;
    }

    // nums 长度已知，但是 target 的数目未知
    // N = nums.filter(x => x==target).size
    public int pick(int target) {
        int cnt = 0, ret = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != target) { 
                continue;
            }

            cnt++;
            if (rand.nextInt(cnt) == 0) { // 抽样的 m = 1
                ret = i;
            }
        }
        return ret;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int param_1 = obj.pick(target);
 */
```

## 洗牌算法

对于洗牌问题：从一个有限集合生成一个随机排列（数组随机排序），一般存在着两种算法。

Fisher-Yates Shuffle 是比较通俗的算法：

1. 初始化原始数组和新数组，原始数组长度为 n(已知)；
2. 从还没处理的数组（假如还剩 k 个）中，随机产生一个 `[0, k)` 之间的数字 p（假设数组从 0 开始）；
3. 从剩下的 k 个数中把第 p 个数取出添加到新数组最后；
4. 重复步骤 2 和 3 直到数字全部取完；
5. 从步骤 3 取出的数字序列便是一个打乱了的数列。

问题是时间复杂度为 `O(n^2)`，因为 `list.remove(p)` 操作是线性时间的，总共发生 n 次。

**改进算法 Knuth-Durstenfeld Shuffle 在原始数组（或拷贝数组）上对数字进行交换，
时间复杂度优化到 `O(n)`，是最推荐的洗牌算法。**模板如下：

```
int[] shuffle(int[] nums) {
    int n = nums.length;
    var res = Arrays.copyOf(nums, n); // 如果可以修改原数组就不用拷贝
    Random rand = new Random();
    for (int i = n - 1; i >= 0; i--) { // 也可以从前向后扫描，但是要修改 rand
        int tmp = res[i];
        // 每次都从闭区间 [0, i] 中随机选取元素进行交换
        // 注意包括 i，即它可能与自己交换
        int id = rand.nextInt(i + 1); 
        res[i] = res[id];
        res[id] = tmp;
    }
    return res;
}
```

**分析洗牌算法正确性的必要条件：产生的结果必须有 n! 种可能，否则就是错误的。**
因为一个长度为 n 的数组的全排列就有 n! 种，也就是说打乱结果总共有 n! 种。
算法必须能够反映这个事实，才是正确的。依此可以说明下面的写法是错误的，
因为这种写法得到的所有可能结果有 `n^n` 种，而不是 n! 种，而 `n^n` 不是 n! 的整数倍。

```
void shuffle(int[] arr) {
    int n = arr.length();
    for (int i = 0 ; i < n; i++) {
        // 每次都从闭区间 [0, n-1] 中随机选取元素进行交换
        int rand = randInt(0, n - 1);
        swap(arr[i], arr[rand]);
    }
}
```

## 蒙特卡罗

蒙特卡罗方法（Monte Carlo method），也称统计模拟方法，是 1940 年代中期由于科学技术的发展和电子计算机的发明，
而提出的一种以概率统计理论为指导的数值计算方法。是指使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。
通常可以用来验证概率相关算法的正确性。比如高中有道数学题：往一个正方形里面随机打点，这个正方形里紧贴着一个圆，
告诉你打点的总数和落在圆里的点的数量，让你计算圆周率。用蒙特卡罗验证上面的洗牌算法的正确性如下：

```
void shuffle(int[] arr);

int N = 1000000; // 重复实验 1000000 次
HashMap count; // 作为直方图
for (i = 0; i < N; i++) {
    int[] arr = {1,2,3};
    shuffle(arr);
    // 此时 arr 已被打乱
    count[arr] += 1；
}
for (int feq : count.values()) 
    print(feq / N + " "); // 频率应当相近
```

# 数学与数字

## 同余定理

同余定理：两个整数同时除以一个整数得到的余数相同，则二整数同余。记作a ≡ b(mod m)。

1. 对于同一个除数，两个数之和（或差）与它们的余数之和（或差）同余。
2. 对于同一个除数，两个数的乘积与它们余数的乘积同余。
3. 对于同一个除数，如果有两个整数同余，那么它们的差就一 定能被这个除数整除。
4. 对于同一个除数，如果两个数同余，那么他们的乘方仍然同余。

同余定理的加法乘法应用:

> (a + b) % m = (a % m + b % m) % m
>
> (a - b) % m = (a % m - b % m + m) % m 
> 
> (a * b) % m = ((a % m) * (b % m)) % m
>
> (a ^ b) % m = ((a % m) ^ b) % m 

```
证明式一：

设 a = k1 * m + r1，b = k2 * m + r2
则 (a + b) % m = ((k1 * m + r1) + (k2 * m + r2)) % m
               = ((k1 + k2) * m + (r1 + r2)) % m
               = (r1 + r2) % m
               = (a % m + b % m) % m

证明式二：

设 a = k1 * m + r1，b = k2 * m + r2
则 (a * b) % m = ((k1 * m + r1) * (k2 * m + r2)) % m
             = (k1 * k2 * m^2 + (k1 * r2 + k2 * r1) * m + r1 * r2) % m
             = (r1 * r2) % m
             = ((a % m) * (b % m)) % m
```

高精度求模法和快速幂取模都是利用了同余定理。

```
// 高精度求模法
int mod(string a, int b) //高精度 a 除以单精度 b
{
    int d = 0;
    for (int i = 0; i < a.size(); i++)
        d = (d * 10 + (a[i] - '0')) % b; //求出余数
    return d;
}
```

快速幂算法是利用分治法在 `O(logN)` 的时间复杂度内求出 `整数 X 的 N 次方` 的值的算法。
算法原理为：

> x^2n = (x*x)^n
> 
> x^(2n+1) = x * x^2n = x * (x*x)^n

2n 次乘法变成 n+1 次乘法（x*x 的结果可以保存下来，不用反复计算），而
2n+1 次乘法变成 n+2 次乘法（奇数次多出来的一个乘法单独计算）。

迭代实现如下：

```
int qpow(int x, int n) {
    int res = 1;
    while (n) { // 进行快速幂运算，n 为当前的指数值，n 为 0 的时候运算结束
        if (n & 1) { // 用位运算的方式判断 n 是否为奇数，速度更快，等价于 n % 2
            res *= x; // 如果 n 是奇数，那么需要将 x 存入运算结果中
        }  
        x *= x; 
        n >>= 1; // 用位运算的方式进行 n/2，速度更快，等价于 n /= 2
    }
    return res;
}
```

数据太大时，64 位甚至 128 位的整型都无法表示，因此在这个基础上加上取余运算。

```
int qpow(int x, int n) {
    int res = 1;
    while (n) { 
        if (n & 1) { 
            res = res * x % m; // 有乘法的地方取余
        }  
        x = x * x % m; // 有乘法的地方取余
        n >>= 1; 
    }
    return res;
}
```

递归实现很简单（最推荐）：

```
int qpow(int x, int n, int m) {
    if (n == 0) {
        return 1;
    }

    return qpow(x * x % m, n >>> 1) * (n % 2 == 0 ? 1 : x) % m;
}
```

## 数位操作

```
// 把给定的数字分成指定位数的数组
// INPUT: 14458, num[5]
// OUTPUT: num[5]{8,5,4,4,1}
public static void numToArray(int number, int[] num) {
    for (int i = 0; i < num.length; i++) {
        num[i] = number % 10;
        number /= 10;
    }
}

// 把给定的数组变成数字
// INPUT: num[5]{8,5,4,4,1}
// OUTPUT: 14458, num[5]
public static int arrayToNum(int[] num) {
    int n;

    for (int i = 0; i < num.length; i++) {
        n = n * 10 + num[i];
    }

    return n;
}
```

## 最小公约数与最小公倍数

```
// 求a,b的最小公约数，利用辗转相除法，其实是利用定理 gcd(a, b) == gcd(b, a % b)
// 由此可以递归，边界是 gcd(a, 0) == a
public static int gcd(int a, int b) {
    if (b == 0) {
        return a;
    }

    return gcd(b, a % 10);
}

// 求a,b的最小公倍数，利用上面求到的最小公约数 d，
// lcm = (a * b) / d，为了防止 a*b 溢出，写成 (a / d) * d
public static int lcm(int a, int b) {
    return a / gcd(a, b) * b;

}
```

## 分数

```
// 分数，保存分子分母，方便起见，使用假分数
class Fraction {
    int up, down;

    // 化简，使其满足三个条件：
    // 1. 分母始终为正数
    // 2. 如果分子是0，则分母是1
    // 3. 分子分母最小公约数是1
    public void reduction() {
        if (down < 0) {
            down = -down;
            up = -up;
        }

        if (up == 0) {
            down = 1;
        } else {
            // 记得取绝对值
            int d = gcd(Math.abs(up), Math.abs(down));
            up /= d;
            down /= d;
        }
    }

    // 分数的除法，加减乘同理，返回自己，方便链式调用
    public Fraction dividedBy(Fraction f) {
        up *= f.down;
        down *= f.up;
        // 结果记得化简
        reduction();

        return this;
    }

    // 输出分三种情况：
    // 1. 如果分母为1，则是整数，只输出分子 
    // 2. 如果分子绝对值大于分母，则是假分数，可以选择按带分数形式输出
    // 3. 其他情况，是真分数直接输出
    public void print() {
        reduction();  // 记得先化简

        if (down == 1) {
            System.out.print(up);
        } else if (Math.abs(up) > down) {
            // 注意比较和输出分子时都要取绝对值
            System.out.printf("%d %d/%d", up / down, Math.abs(up) % down, down);
        } else {
            System.out.printf("%d/%d", up, down);
        }
    }
}
```

## 素数

```
// 判断一个数是不是素数，注意1既不是素数又不是合数，因子只需要判断到这个数的开方
public static boolean isPrime(int n) {
    if (n <= 1) {
        return false;
    }

    int sqr = (int) Math.sqrt(n * 1.0);// 变量外提，强制类型转换，以优化循环速度
    for (int i = 2; i <= sqr; i++) { // 从2开始判断，注意i<=sqr含有等号
        if (n % i == 0) {
            return false;
        }
    }

    // 实践中，如果n比较小（10的9次方之内），可以简单的这样写
    // for(int i = 2; i * i <=n; i++){
    //     if(n % i == 0)
    //         return false;
    // }

    return true;
}

// 获取一张直到给定数的素数表，从小数字开始，每发现一个素数，就向后筛去这个素数的整倍数
public static ArrayList<Integer> getPrimeList(int max) {
    // 带标记表的方法
    boolean[] mark = new boolean[max + 1]; // 偏移1个单位，使索引与数字对应
    ArrayList<Integer> primes = new ArrayList<>();

    for (int i = 2; i <= max; i++) { // 从2开始
        if (!mark[i]) { // 注意，标记为false即是素数，否则不做任何处理
            primes.add(i);

            for (int j = i + 1; j <= max; j += i) { // 从i+1开始向后筛去整倍数，步进是i
                mark[j] = true;
            }
        }
    }

    return primes;
}
```

---

> 参考：
> 
> [李威威的简书博客](https://www.jianshu.com/p/b6ad653fb2e1)
>
> [labuladong 的 LeetCode 解答](https://leetcode-cn.com/problems/shuffle-an-array/solution/xi-pai-suan-fa-shen-du-xiang-jie-by-labuladong/)
>
> [kkbill 的 LeetCode 解答](https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/cong-zui-ji-chu-de-jiang-qi-ru-he-zuo-dao-jun-yun-/)
>
> [“大专栏”博客](https://www.dazhuanlan.com/2019/08/17/5d57688f808cc/)
>
> 最后附上 GitHub：<https://github.com/gonearewe>
