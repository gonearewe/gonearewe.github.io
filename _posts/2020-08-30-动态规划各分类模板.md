---
layout: post
title: 动态规划各分类模板
subtitle: 常用算法模板系列（二）
date: 2020-08-30
author: John Mactavish
header-img: img/post-bg-brandon-woods-montrone.jpg
catalog: true
tags:
  - 算法
  - 动态规划
---

<!-- 数字三角形模型 最长上升子序列模型 背包模型 状态机模型 状态压缩DP 区间DP 树形DP 数位DP 单调队列优化DP 斜率优化DP -->

## 线性 DP

```
给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。

一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。

请你返回乘积为正数的最长子数组长度。

示例  1：
输入：nums = [1,-2,-3,4]
输出：4
解释：数组本身乘积就是正数，值为 24 。

示例 2：
输入：nums = [0,1,-2,-3,-4]
输出：3
解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。

示例 3：
输入：nums = [-1,-2,-3,0,1]
输出：2
解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。

示例 4：
输入：nums = [-1,2]
输出：1

示例 5：
输入：nums = [1,2,3,5,-6,4,0,10]
输出：4

提示：
1 <= nums.length <= 10^5
-10^9 <= nums[i] <= 10^9
```

***首先不看题目，看数组长度，`N = 10^5`，对于这个规模的数据，`O(N^2)` 的算法可能会超时，
这题和树、二分什么的也没有关系，考虑是不是一个 `O(N)` 的算法。***

明显感觉是动态规划问题，注意状态是怎么转换的：

1. 正数乘正数还是正数，乘负数变成负数；
2. 负数乘正数还是负数，乘负数变成正数。
   
假如设 `dp[i]` 是以 `nums[i]` 结尾，乘积为正的最长子数组的长度。那么因为 `dp[i+1]` 不仅仅与 `dp[i]` 有关，
还可能由负数乘负数转化而来，这个设计不合理。

所以设 `positive[i]` 是以 `nums[i]` 结尾，乘积为正的最长子数组的长度，
又设 `negative[i]` 是以 `nums[i]` 结尾，乘积为负的最长子数组的长度。
列写正式的状态转换式：

```
if (nums[i] > 0):
    positive[i] = positive[i-1] + 1 
    negative[i] = negative[i-1] + 1
if (nums[i] < 0):
    positive[i] = negative[i-1] + 1 
    negative[i] = positive[i-1] + 1
```

除状态转换式外还需要的是初始状态，这个简单，单独判断一下就好了：

```
positive[0] = nums[0] > 0 ? 1 : 0
negative[0] = nums[0] < 0 ? 1 : 0
```

但是**先别急着写代码，有了思路之后的第一件事应该是代入用例验证一下，以防设计出错，写了半天白忙活。**
看了用例一下就发现了，还有 `nums[i] == 0` 的情况没有考虑。
以 `nums[i]` 结尾，乘积为正或负的最长子数组的长度显然都是零了。那么：

```
if (nums[i] == 0):
    positive[i] = 0
    negative[i] = 0
```

再看一下示例 2，发现不对劲：

```
nums       0 1 -2 -3 -4
positive   0 1  2  3  4
negative   0 1  2  3  4
expected: 3 found: 4
```

原因在于 `nums[0] == 0` 重置了状态，其后的 `positive[1]`、`negative[1]` 需要像初始状态一样考虑。
换句话说，当 `negative[i-1] == 0`，`nums[i]` 为正数时 `negative[i]` 还是 0，为负数时也没有
负负得正的效果，`positive[i]` 不等于 `negative[i-1] + 1`。
综上，修正状态转换式：

```
if (nums[i] > 0):
    positive[i] = positive[i-1] + 1 
    negative[i] = negative[i-1] == 0 ? 0 : negative[i-1] + 1
if (nums[i] < 0):
    positive[i] = negative[i-1] == 0 ? 0 : negative[i-1] + 1 
    negative[i] = positive[i-1] + 1
```

同时注意，这里也包含了初始状态，不需要再单独考虑。

最后注意，**状态 i 仅仅与状态 i-1 有关，所以可以对这个一维线性动态规划进行状态压缩**，仅用迭代
变量 positive, negative 代替动态规划的数组。

```
class Solution {
    public int getMaxLen(int[] nums) {
        int positive = 0, negative = 0;
        int res = 0;
        for (final int num : nums) {
            if (num == 0) {
                positive = 0;
                negative = 0;
            } else if (num > 0) {
                positive++;
                negative = negative == 0 ? 0 : negative + 1;
            } else {
                int lastNegative = negative;
                negative = positive + 1;
                positive = lastNegative == 0 ? 0 : lastNegative + 1;
            }
            res = Math.max(res, positive);
        }
        return res;
    }
}
```

## 背包 DP

背包问题一般这样描述：有 N 种物品和一个容量为 V 的背包。第 i 种物品的费用是 `c[i]`，
价值是 `w[i]`。求解将哪些物品装入背包可使价值总和最大。如果每种物品仅有一件，可选择放或不放，那么
就是 ***0-1 背包问题***；如果每种物品都有无限件可用，那么就是***完全背包问题***。

先考虑每种物品仅有一件的情况。
一般这样定义状态：`dp[i][v]` 表示前 i 种物品恰放入一个容量为 v 的背包可以获得的最大价值。则其状态转移方程便是：

> dp[i][v] = f{dp[i-1][v],dp[i-1][v-c[i]]+w[i]} // f 函数在这里是 max

“将前 i 种物品放入容量为 v 的背包中”这个子问题，若只考虑第 i 种物品的策略（放或不放），
那么就可以转化为一个只牵扯前 i-1 种物品的问题。如果不放第 i 种物品，
那么问题就转化为“前 i-1 种物品放入容量为 v 的背包中”，价值为 `dp[i-1][v]`；如果放第 i 种物品，
那么问题就转化为“前 i-1 种物品放入剩下的容量为 `v-c[i]` 的背包中”，
此时能获得的最大价值就是 `dp[i-1][v-c[i]]` 再加上通过放入第 i 种物品获得的价值 `w[i]`。

注意状态转移方程中计算 `dp[i][v]` 时只使用到了上一层正上方（`dp[i-1][v]`）和左边（`dp[i-1][v-c[i]]`）的状态，
因此我们可以在实现时压缩状态数组：

```
for i=1..N
    for v=V..0
        if v>=c[i]
            dp[v]=f{dp[v],dp[v-c[i]]+w[i]}
        else
            dp[v]=f{dp[v]}
```

注意内部循环从 V 到 0 进行，这样保证了 `dp[v-c[i]]` 访问的是上一层的状态。
`v < c[i]` 时当前状态只可能从上一层正上方迁移而来，在压缩状态数组的实现中刚好什么都不需要做，
因此我们事实上这样写代码：

```
for i=1..N
    for v=V..c[i] // 逆序
        dp[v]=f{dp[v],dp[v-c[i]]+w[i]}
```

接下来考虑每种物品有无限件的情况。那么状态转移方程就变成：

> dp[i][v] = f{dp[i-1][v-k\*c[i]]+k\*w[i] \| 0<=k\*c[i]<=v}

事实上，它等价于：

> dp[i][v] = f{dp[i-1][v],dp[i][v-c[i]]+w[i]}

注意这里状态转移方程中计算 `dp[i][v]` 时使用到了上一层正上方（`dp[i-1][v]`）和当前层左边（`dp[i][v-c[i]]`）的状态，
因此我们用压缩状态数组实现时内部循环应当改为顺序（从 `c[i]` 到 V）以保证 `dp[v-c[i]]` 访问的是当前层的状态：

```
for i=1..N
    for v=c[i]..V // 顺序
        dp[v]=f{dp[v],dp[v-c[i]]+w[i]}
```

这样计算的结果中，选择的物品是无序的，即方案 `[1,1,3]` 与方案 `[3,1,1]` 被认为是同一种。
如果碰到了 [377.组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/) 这样的题目，
要求区分组合 `(1,1,3)` 与 `(3,1,1)` 等，需要修改状态转移方程为：

> dp[i][v] = f{dp[i-1][v],dp[N][v-c[i]]+w[i]} // f 函数在这里是 sum

因为其中的 `dp[N][v-c[i]]` 表示“将所有种类物品放入容量为 `v-c[i]` 的背包中的组合数”。
下面讨论实现：因为 `dp[i][v]` 用到了左下角的值，所以 dp 矩阵扫描方式改为外层按列扫描。

```
for v=1..V // 内外循环调换顺序
    for i=1..N
        if v>=c[i]
            dp[v]=f{dp[v],dp[v-c[i]]+w[i]} // 不是矩阵转置，dp 索引还是 v
        else
            dp[v]=f{dp[v]}
```

实际的问题当然不会描述得这么明显，所以需要能根据特征识别背包问题或把问题转化为背包问题。
背包问题的特征是一系列的可选择元素（DP 的层数）、给定的有限数的约束条件（如物品总重量 W、元素的加和 S，
作为 DP 矩阵的列）和代求的不定的量（如是否有可行方案、可行方案数目、元素的加和的最值，作为 `dp[i][j]` 的值）。
有时候还需要根据方程关系进行等价变形以得到背包问题，比如下面这个问题：

```
// 给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。
// 对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。
// 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

// 示例：
// 输入：nums: [1, 1, 1, 1, 1], S: 3
// 输出：5
// 解释：

// -1+1+1+1+1 = 3
// +1-1+1+1+1 = 3
// +1+1-1+1+1 = 3
// +1+1+1-1+1 = 3
// +1+1+1+1-1 = 3

// 一共有5种方法让最终目标和为3。
//  
// 提示：
// 数组非空，且长度不会超过 20 。
// 初始的数组的和不会超过 1000 。
// 保证返回的最终结果能被 32 位整数存下。


// 此问题可以转化为子集划分问题
//
// 将一个集合划分成两个子集 A,B, 问满足 sum(A) - sum(B) = Target的分法有多少种
// 两端同时加上集合元素和 sum,得到 2 * sum(A) = Target + sum ==> sum(A) = (Target + sum) / 2
//
// 又已知 sum(A) = sum(B) + Target >= Target, sum = sum(A) + sum(B) >= sum(A)
// 故得预筛选条件 sum >= Target 和 (Target + sum) % 2 == 0

import java.util.Arrays;

class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = Arrays.stream(nums).sum();
        if (sum < S || (sum + S) % 2 != 0) {
            return 0;
        }

        int[] dp = new int[sum + 1];
        dp[0] = 1; // 0 元素加和为 0 有 1 种方案
        for (int num : nums) {
            for (int j = dp.length - 1; j >= num; j--) {
                dp[j] += dp[j - num];
            }
        }
        return dp[(sum + S) / 2];
    }
}
```

最后总结一下模板：

> dp[i][v] = f{dp[i-1][v],dp[`i-1`][v-c[i]]+w[i]} // 0-1 背包
> 
> dp[i][v] = f{dp[i-1][v],dp[`i`][v-c[i]]+w[i]} // 完全背包
> 
> dp[i][v] = f{dp[i-1][v],dp[`N`][v-c[i]]+w[i]} // 考虑物品顺序的完全背包

对于其中的 f 函数：

- 在“方案是否存在”问题中，`f = or`(布尔或)
- 在“方案有多少种”问题中，`f = sum`
- 在“最优方案”问题中，`f = best`(比如 max 或者 min)

至于具体实现中的扫描方式，根据状态转移方程很容易想出来，初始条件一般也不难，都不需要记忆。

---

> 最后附上 GitHub：<https://github.com/gonearewe>
