---
layout:     post
title:      Redis 笔记
subtitle:   NoSQL 学习
date:       2021-03-24
author:     John Mactavish
header-img: img/post-bg-lake-blue.jpg
catalog: true
tags:
     - Redis

---

Redis 是一个开源的内存数据库，提供 5 种常用的数据结构，支持事务、持久化、Lua 脚本和多种集群方案等，
可应用作计数器、数据库缓存、热点数据缓存等。

# 持久化

Redis 是内存型数据库，如果需要保证数据在断电后不会丢失，可以将内存中的数据持久化到硬盘上。
持久化有两种方法：RDB（Redis Database）和 AOF（Append Only File）。

## Redis Database

RDB 通过创建快照来保存内存数据在某个时间点的副本，快照以二进制写入文件，
之后可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
注意快照按时间点保存，这意味如果系统发生故障，将会丢失最近一次创建快照之后的数据。

创建快照的方式有：

- 客户端向 Redis 服务器发送 BGSAVE 命令，Redis 服务器调用 fork 创建子进程来将快照写入硬盘，
同时，父进程可以继续处理命令请求
- 客户端向 Redis 服务器发送 SAVE 命令，Redis 服务器单进程阻塞地创建快照，期间不理会其他命令请求，这种方式不常用
- 用户设置的 save 配置选项的条件满足时，Redis 自动触发 BGSAVE 命令
- Redis 接收 SHUTDOWN 命令或标准 TERM 信号后，在关闭服务器前会执行 SAVE 命令
- 一个 Redis 服务器连接另一个 Redis 服务器，并向对方发送 SYNC 命令准备复制时，如果主服务器最近未执行 BGSAVE 命令，则执行 BGSAVE 命令
  
在 Linux 上，fork 创建的子进程惰性地创建自己的内存空间。这意味着，父子进程一开始共享底层的数据段、栈与堆，
内核把这些区域的访问权限设为只读，父子中任一进程试图修改时触发 Copy on Write 机制，为修改区域按页创建副本，
然后修改自己的副本。相比于在 fork 系统调用时立刻创建自己的内存空间，Copy on Write 同样保证进程地址空间隔离，
但是减少了无效操作（毕竟子进程很少需要修改整个内存空间）。BGSAVE 命令利用此特性既避免了并发问题又
在一定程度上保证了备份期间处理其他命令的能力。

> fork 机制的细节可参考《Unix 环境高级编程（第三版）》第八章————进程控制。

但是注意，创建进程与进程间资源争抢同样是不小的开销，尤其在数据量比较大时（内存占用几十个 GB），
BGSAVE 创建快照的速度往往比 SAVE 慢。按照《Redis 实战》书作者的经验之谈，在 68GB 的 Xen 虚拟机上，
占用 50GB 的 Redis 服务器执行 BGSAVE 命令时，创建子进程需要花费 15 秒以上，创建快照需要 15~20 分钟，
相比之下，SAVE 只需要 3~5 分钟。因此，可以在 Redis 服务器能够接受完全中止服务时（比如深夜使用频率低时）
使用 SAVE 命令备份。

鉴于创建快照对性能不小的影响，RDB 持久化方式最多只能每隔一段时间进行一次。
这在持久化需求不敏感时还可接受，但如果想要实时持久化，需要看看下面的方法。

## Append Only File

我们可以仿照传统数据库的日志系统，将对数据库的每一条写命令同步写入磁盘，系统崩溃后只需顺序执行所有的写命令即可完成恢复。
磁盘写操作被平摊到每一条写命令后对性能的影响微乎其微，而且文件的只追加（Append Only）写入本身也很快。

鉴于 AOF 的写入的“少量多次”的特性，这里需要讨论操作系统的文件同步机制。为了减少开销较大的 I/O 操作的次数，
操作系统可能并不会在文件写入的系统调用中将数据真的写入物理磁盘，而是放进内核的缓冲区中，待缓冲区中数据量较可观时再一次性
冲刷（flush）进物理磁盘。这提高了 I/O 效率，但在数据库这种特殊应用中却可能导致系统崩溃后一定量的写命令的丢失。
但是逐个命令冲刷缓冲区，甚至跳过缓冲区直写磁盘（Write Through）也确实很影响性能。
我们只好在性能与健壮性之间取个平衡，通常设置 Redis 命令 appendfsync 为 everysec 以要求每秒钟把缓冲区同步到磁盘一次。
这样在一定程度上保证了 I/O 效率，同时确保用户最多丢失系统崩溃前一秒钟内的写命令。

既然 AOF 在性能（持久化开销被均摊）与健壮性（丢失数据的时间窗口小）两方面都优于 RDB，那后者还有什么存在的必要吗？
那是因为 AOF 的工作机制额外带来了缺陷。不难想到，RDB 中保存的每项数据都至少对应 AOF 中的一条写命令，而且一般都不止一条。
比如说，一项缓存可能会多次失效、重新设置、再失效……留下多个写命令；又或者它会被多次赋值。这导致 AOF 日志文件大小一般远超 RDB 的快照。
从另一个方向考虑，RDB 的大小受限于机器内存大小（最多将占满内存的 Redis 数据备份），而 AOF 文件的大小完全可以无限扩展直至耗尽硬盘空间。

---

> 参考资料：
> 
> Redis 实战（Redis in Action）
> 
> Redis 设计与实现（The Design and Implementation of Redis）
> 
> My GitHub Account <https://github.com/gonearewe>
