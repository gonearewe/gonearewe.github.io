---
layout:     post
title:      Redis 笔记
subtitle:   NoSQL 学习
date:       2021-03-24
author:     John Mactavish
header-img: img/post-bg-lake-blue.jpg
catalog: true
tags:
     - Redis

---

Redis 是一个开源的内存数据库，提供 5 种常用的数据结构，支持事务、持久化、Lua 脚本和多种集群方案等，
可应用作计数器、数据库缓存、热点数据缓存等。

# 数据类型与底层结构

Redis 目前支持 5 种数据类型，分别是：

- String（字符串）
- List（列表）
- Hash（字典）
- Set（集合）
- Sorted Set（有序集合）

字符串无需多介绍，可存储简单数据，常用于缓存、计数器

因为 Redis 使用 C 实现，而 C 语言很缺少必要的数据结构，所以 Redis 自己实现了一些底层结构。

## Simple Dynamic String

Redis 的默认字符串表示用的是 SDS（Simple Dynamic String），它的实现类似于 Java 中的 ArrayList，所以具体实现不多赘述。
SDS 通过成员变量 len 保存字符串实际长度，但是在 len+1 位置仍然保存一个 "\0"，这是为了利用 C 的 string 函数以方便开发。
但是相比与原生的 string 函数，SDS 的 API 保证安全性，例如字符串拼接函数（把 src 拼接到 dest 后面）

> char *strcat(char *dest, const char *src);

在 dest 不拥有足够空间容纳 src 时会发生缓冲区溢出；但是 SDS 的类似 API sdscat 却会通过严格的检查避免这种错误。

同时，SDS 实际存储的是二进制数组，而并不对其作过多假设，如果用户需要利用 SDS 存特定编码格式的字符串，他需要自己处理。

## LinkedList

Redis 自己实现了一个双链表。




# 持久化

Redis 是内存型数据库，如果需要保证数据在断电后不会丢失，可以将内存中的数据持久化到硬盘上。
持久化有两种方法：RDB（Redis Database）和 AOF（Append Only File）。

## Redis Database

RDB 通过创建快照来保存内存数据在某个时间点的副本，快照以二进制写入文件，
之后可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
注意快照按时间点保存，这意味如果系统发生故障，将会丢失最近一次创建快照之后的数据。

创建快照的方式有：

- 客户端向 Redis 服务器发送 BGSAVE 命令，Redis 服务器调用 fork 创建子进程来将快照写入硬盘，
同时，父进程可以继续处理命令请求
- 客户端向 Redis 服务器发送 SAVE 命令，Redis 服务器单进程阻塞地创建快照，期间不理会其他命令请求，这种方式不常用
- 用户设置的 save 配置选项的条件满足时，Redis 自动触发 BGSAVE 命令
- Redis 接收 SHUTDOWN 命令或标准 TERM 信号后，在关闭服务器前会执行 SAVE 命令
- 一个 Redis 服务器连接另一个 Redis 服务器，并向对方发送 SYNC 命令准备复制时，如果主服务器最近未执行 BGSAVE 命令，则执行 BGSAVE 命令
  
在 Linux 上，fork 创建的子进程惰性地创建自己的内存空间。这意味着，父子进程一开始共享底层的数据段、栈与堆，
内核把这些区域的访问权限设为只读，父子中任一进程试图修改时触发 Copy on Write 机制，为修改区域按页创建副本，
然后修改自己的副本。相比于在 fork 系统调用时立刻创建自己的内存空间，Copy on Write 同样保证进程地址空间隔离，
但是减少了无效操作（毕竟子进程很少需要修改整个内存空间）。BGSAVE 命令利用此特性既避免了并发问题又
在一定程度上保证了备份期间处理其他命令的能力。

> fork 机制的细节可参考《Unix 环境高级编程（第三版）》第八章————进程控制。

但是注意，创建进程与进程间资源争抢同样是不小的开销，尤其在数据量比较大时（内存占用几十个 GB），
BGSAVE 创建快照的速度往往比 SAVE 慢。按照《Redis 实战》书作者的经验之谈，在 68GB 的 Xen 虚拟机上，
占用 50GB 的 Redis 服务器执行 BGSAVE 命令时，创建子进程需要花费 15 秒以上，创建快照需要 15~20 分钟，
相比之下，SAVE 只需要 3~5 分钟。因此，可以在 Redis 服务器能够接受完全中止服务时（比如深夜使用频率低时）
使用 SAVE 命令备份。

鉴于创建快照对性能不小的影响，RDB 持久化方式最多只能每隔一段时间进行一次。
这在持久化需求不敏感时还可接受，但如果想要实时持久化，需要看看下面的方法。

## Append Only File

我们可以仿照传统数据库的日志系统，将对数据库的每一条写命令同步写入磁盘，系统崩溃后只需顺序执行所有的写命令即可完成恢复。
磁盘写操作被平摊到每一条写命令后对性能的影响微乎其微，而且文件的只追加（Append Only）写入本身也很快。

鉴于 AOF 的写入的“少量多次”的特性，这里需要讨论操作系统的文件同步机制。为了减少开销较大的 I/O 操作的次数，
操作系统可能并不会在文件写入的系统调用中将数据真的写入物理磁盘，而是放进内核的缓冲区中，待缓冲区中数据量较可观时再一次性
冲刷（flush）进物理磁盘。这提高了 I/O 效率，但在数据库这种特殊应用中却可能导致系统崩溃后一定量的写命令的丢失。
但是逐个命令冲刷缓冲区，甚至跳过缓冲区直写磁盘（Write Through）也确实很影响性能。
我们只好在性能与健壮性之间取个平衡，通常设置 Redis 命令 appendfsync 为 everysec 以要求每秒钟把缓冲区同步到磁盘一次。
这样在一定程度上保证了 I/O 效率，同时确保用户最多丢失系统崩溃前一秒钟内的写命令。

既然 AOF 在性能（持久化开销被均摊）与健壮性（丢失数据的时间窗口小）两方面都优于 RDB，那后者还有什么存在的必要吗？
那是因为 AOF 的工作机制额外带来了缺陷。不难想到，RDB 中保存的每项数据都至少对应 AOF 中的一条写命令，而且一般都不止一条。
比如说，一项缓存可能会多次失效、重新设置、再失效……留下多个写命令；又或者它会被多次赋值。这导致 AOF 日志文件大小一般远超 RDB 的快照。
从另一个方向考虑，RDB 的大小受限于机器内存大小（最多将占满内存的 Redis 数据备份），而 AOF 文件的大小完全可以无限扩展直至耗尽硬盘空间。
过大的日志文件不仅会增加硬盘负担，还会增加读取文件还原数据的时间。

AOF 文件过大核心的原因在于冗余的命令。例如经过：

```
RPUSH list "A" "B"   // ["A", "B"]
RPUSH list "C"       // ["A", "B", "C"]
RPUSH list "D" "E"   // ["A", "B", "C", "D", "E"]
LPOP list            // ["B", "C", "D", "E"]
LPOP list            // ["C", "D", "E"]
RPUSH list "F" "G"   // ["C", "D", "E", "F", "G"]
```

Redis 在内存中实际存储的 list 是 ["C", "D", "E", "F", "G"]，而 AOF 文件却记录下了 6 条命令，
它们完全可以用一条命令 RPUSH list "C" "D" "E" "F" "G" 代替。事实上 Redis 真的可以这样做，它可以用内存中的实际数据重写日志文件。
重写后可以保证内存中每项数据都只对应文件中的一条写命令。重写文件感觉很类似 RDB 操作，但区别在于重写后的文件依然是 AOF 文件，
这意味着它可以继续接受追加命令。

通过向 Redis 发送 BGREWRITEAOF 命令，可以要求 Redis 服务器创建子进程来重写 AOF 文件。这里有两点值得注意。第一，
不能直接修改原文件，否则如果重写过程中系统崩溃，仅有的原文件也会被损坏；我们应当新建一份 AOF 文件，
重写完成后进行重命名，让其原子地覆盖原有的文件。第二，重写过程中可能会有新的写命令到达，
但是子进程只会记录 fork 调用时的内存数据，导致重写过程中写命令丢失；其实同样的问题在 RDB 中也会出现，
但是 RDB 本来就允许较长时间内的数据丢失，所以并不关心。

![aof-1](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/post-2021-redis-aof-1.jpg)

如图所示，fork 调用时父子进程共享的内存数据仅包括 k1，后续的 k2，k3，k4 触发 Copy on Write 机制，
仅写入了父进程的地址空间，而对子进程不可见。解决方法也简单，让父进程记录这些增量的写命令，在子进程完成自己的重写任务后再通知它不就好了。
为此，Redis 在创建子进程后会把增量的写命令同时写入一个额外的 AOF 重写缓冲区，子进程完成重写后会向父进程发送信号，
父进程然后调用信号处理函数，将 AOF 重写缓冲区的内容刷入新的 AOF 文件，随后完成新旧文件的替换，结束整个 AOF 流程。

![aof-2](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/post-2021-redis-aof-2.jpg)

就像 RDB 可以通过 save 选项配置自动 BGSAVE，AOF 也支持 auto-aof-rewrite-percentage 与 auto-aof-rewrite-min-size 选项。
具体用法参考文档。



---

> 参考资料：
> 
> Redis 实战（Redis in Action）
> 
> Redis 设计与实现（The Design and Implementation of Redis）

如果你喜欢我的文章，请我吃根冰棒吧  (o゜▽゜)o ☆

![contribution](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/contribution.jpg)

> 最后附上 GitHub：<https://github.com/gonearewe>
