---
layout: post
title: 设计模式概览
subtitle: 《设计模式：可复用面向对象软件的基础》笔记
date: 2020-10-21
author: John Mactavish
header-img: img/post-bg-helicopter-scrapland-village.jpg
catalog: true
tags:
  - 设计模式
  - 读书笔记
---

# 引言

学习的有效方法是理论与实践相结合，所以既要经常 coding 又要阅读经典书籍；
人对自然的认识程度是螺旋上升的，所以 coding 与读书要交替进行。

《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）是软件工程领域
有关软件设计的最有名的一本书，提出和总结了对于一些常见软件设计问题的标准解决方案，称为软件设计模式。
该书作者是埃里希·伽玛（Erich Gamma）、Richard Helm、Ralph Johnson 和 John Vlissides，后以“四人帮”（Gang of Four，GoF）著称。

我初读这本书大概是一年前，当时只是囫囵吞枣，因为代码量不足以支撑我的理解。在通过实践获得了一些经验的今天，我重新拾起这本书，
于上课时翻翻，竟然只花了两三天时间就基本看完了。而且我对其中的一些内容还产生了“这么自然的设计用得着写进书里作为模式吗”的想法。
想必这就是所谓的“理论与实践相结合”的成果吧。既然如此，索性最后写一篇笔记概述性地总结一下书中的设计模式，以作为消化了这本书的标志，
我今后大概再也不会翻开这本书了，毕竟对我来说已经没有什么新东西了。

书中共计介绍了 23 种设计模式，有两种分类方法：按模式主要用于类还是对象分类和按目的准则分类（如下图，来源于书中插图）。
章节设计是根据后一种分类来的，所以我下面也按照这种分类依次介绍。按本人感觉的新鲜度与重要性程度，23 种设计模式篇幅不等。

![](https://github.com/gonearewe/gonearewe.github.io/blob/master/img/post-2020-design-pattern-1.jpg)

# 创建型模式

创建型模式全部是关于如何创建实例的。这组模式可以被划分为两组：类创建模式及对象创建模式。
类创建模式在实例化过程中有效地使用类之间的继承关系，对象创建范例则使用代理来完成其任务。

## 抽象工厂 (Abstract Factory)

![](https://github.com/gonearewe/gonearewe.github.io/blob/master/img/post-2020-design-pattern-2.jpg)

**面向对象的一个重要的设计思想是：分析出系统中不常改变的部分与经常改变的部分，并确保系统不易被经常改变的部分破坏。**
**一般接口稳定而具体实现易变，所以系统内各部件应该只通过接口（或抽象类）交互。**所以在这里 Application 只接触 GuiFactory 与 Button，
而不关心具体的 Factory 或 Button 的实现。

同时，GuiFactory 接口中的 createButton 方法返回 Button 类型的对象，返回 Button 的哪种实现依赖于使用 GuiFactory 的哪种实现。
为了简洁起见，以上类图仅仅展示了创建一个类型对象的工厂，而在实际中（参考后面的图），通常一个工厂能够创建若干种不同类型的对象（如 Text，Form，Grid 等）。
这也体现了模块分类的思想，把不同种类的 Button 等按操作系统（WinFactory、OSXFactory）的不同分类归放。

这样也获得了将一个系列的产品族统一到一起创建的能力。比如，通过创建 Button、Form 等进一步组装 Login Interface 的方法可以
直接放进 GuiFactory 了。

```java
public interface GuiFactory {
	Button createButton();

	Border createForm();

  LoginInterface createLoginInterface() { // default method
    createForm();
    // ...
    createButton();
  }
}
```

![](https://github.com/gonearewe/gonearewe.github.io/blob/master/img/post-2020-design-pattern-4.jpg)

## 工厂方法 (Factory Method pattern)

工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”

![](https://github.com/gonearewe/gonearewe.github.io/blob/master/img/post-2020-design-pattern-3.jpg)

慢着，有没有搞错，为什么配图与抽象工厂差不多。其实是因为这两个模式本来就很像。
**抽象工厂模式与工厂方法模式最大的区别在于抽象工厂中每个工厂可以创建多个种类的抽象产品。**
具体如何在抽象工厂与工厂方法之间选择可依据实际需求而定。

![](https://github.com/gonearewe/gonearewe.github.io/blob/master/img/post-2020-design-pattern-5.jpg)

## 简单工厂 (Simple Factory pattern)

这不是书中介绍的 23 种设计模式之一，确是平时最常用到的工厂模式变种。

![](https://github.com/gonearewe/gonearewe.github.io/blob/master/img/post-2020-design-pattern-6.jpg)

它简化了工厂的存在，**用一个具体工厂的多个选项(“创建”方法的输入参数)代替用抽象工厂的多个子类来创建产品**。

## 构造器 (Builder Pattern)

![](https://github.com/gonearewe/gonearewe.github.io/blob/master/img/post-2020-design-pattern-6.jpg)

又名建造模式，它用于复杂对象是一步一步创建出来的情形。它十分实用，使用场景易于识别，具体实现如下：

```java
// Sample comes from Netty Source Code and is modified
// https://github.com/netty/netty/blob/bd8cea644a07890f5bada18ddff0a849b58cd861/codec-http/src/main/java/io/netty/handler/codec/http/cors/CorsConfigBuilder.java
public final class CorsConfigBuilder {
    final Set<String> origins;
    final boolean anyOrigin;
    boolean allowNullOrigin;
    boolean enabled = true; // 部件可能有默认值，因而不是所有部件都必须 build
    final Set<String> exposeHeaders = new HashSet<String>(); 
    long maxAge;

    CorsConfigBuilder() {
        anyOrigin = true;
        origins = Collections.emptySet();
    }

    // 部件建造方法一般返回 Builder 自身以便链式调用
    public CorsConfigBuilder allowNullOrigin() {
        allowNullOrigin = true;
        return this;
    }

    public CorsConfigBuilder disable() {
        enabled = false;
        return this;
    }

    public CorsConfigBuilder exposeHeaders(final String... headers) {
        exposeHeaders.addAll(Arrays.asList(headers));
        return this;
    }

    public CorsConfigBuilder maxAge(final long max) {
        maxAge = max;
        return this;
    }

    // 结束建造，返回产品
    public CorsConfig build() {
        // ...
        return new CorsConfig(this);
    }
}

// 有时也会把体积较小的 Builder 作为产品的内部类以更好分类归放
public final class CorsConfig {
    // correspond fields
    private final Set<String> origins;
    private final boolean anyOrigin;
    private final boolean enabled;
    private final Set<String> exposeHeaders;
    private final long maxAge;
    private final boolean allowNullOrigin;

    // 仅支持由 Builder 创建此类
    CorsConfig(final CorsConfigBuilder builder) {
        // 深拷贝以防 Builder 被重复使用
        origins = new LinkedHashSet<String>(builder.origins); 
        anyOrigin = builder.anyOrigin;
        enabled = builder.enabled;
        exposeHeaders = builder.exposeHeaders;
        maxAge = builder.maxAge;
        allowNullOrigin = builder.allowNullOrigin;
    }
}
```

## 单例模式 (Singleton pattern)

许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，
该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。
这种方式简化了在复杂环境下的配置管理。这个模式要求一个类必须只有一个实例存在。

这个模式也十分实用，推荐的 Java 具体实现有三：

```java
// 双重检查模式、懒汉模式、线程安全
public class Singleton {
    private volatile static Singleton singleton;  // volatile 修饰静态对象
    private Singleton (){}  // 屏蔽构造器

    public static Singleton getSingleton() {  
        if (singleton == null) {  // 同步前通过判读是否初始化，减少不必要的同步
            synchronized (Singleton.class) {  // 同步，线程安全
                if (singleton == null) { // 双重检查 
                    singleton = new Singleton();  // 创建 singleton 对象
                }  
            }  
        }  

        return singleton;  
    }  
}
```

为什么要使用 volatile 修饰？

虽然已经使用 synchronized 进行同步，但在创建对象时，会有下面的伪代码：

```
memory=allocate(); //1：分配内存空间
ctorInstance();   //2: 初始化对象
singleton=memory; //3: 设置singleton指向刚排序的内存空间
```

当线程 A 在执行上面伪代码时，2 和 3 可能会发生重排序，因为重排序并不影响运行结果，还可以提升性能，所以 JVM 是允许的。
如果此时伪代码发生重排序，步骤变为 1->3->2,线程 A 执行到第 3 步时，线程 B 调用 getsingleton 方法，在判断 singleton==null 时不为 null，
则返回 singleton。但此时 singleton 并还没初始化完毕，线程 B 访问的将是个还没初始化完毕的对象。
当声明对象的引用为 volatile 后，伪代码的 2、3 的重排序在多线程中将被禁止。

```java
// 静态内部类模式、懒汉模式、线程安全
public class Singleton { 
    private Singleton(){}

    public static Singleton getSingleton(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} 
```



```java
// 枚举单例模式、饿汉模式、代码简洁、线程安全、能在序列化和反射中保证实例的唯一性、没有被广泛采用
public enum Singleton {
    INSTANCE;
    
    public void doSomething(){
        //todo doSomething
    }
}
```

Joshua Bloch 大神在《Effective Java》中推荐这个方法。

# 结构型模式

这组模式都是关于类及对象组合关系的。

# 行为型模式

这组模式都是关于对象之间如何交互的。

<!-- 原型 (Prototype pattern)
适配器(Adapter pattern)
桥接(Bridge pattern)
组合(Composite pattern)
装饰(Decorator pattern)
外观(Façade pattern)
享元(Flyweight pattern)
代理(Proxy pattern)
责任链(Chain-of-responsibility pattern)
命令(Command pattern)
翻译器(Interpreter pattern)
迭代器(Iterator pattern)
中介者(Mediator pattern)
回忆(Memento pattern)
观察者(Observer pattern)
状态机(State pattern)
策略(Strategy pattern)
模板方法(Template method pattern)
参观者(Visitor) -->
---
如果你喜欢我的文章，请我吃根冰棒吧  (o゜▽゜)o ☆

![contribution](https://github.com/gonearewe/gonearewe.github.io/blob/master/img/contribution.jpg)

> [新小梦的掘金博客](https://juejin.im/post/6844903858276139021) 
>
> 相当一部分内容来自 WiKi 相关词条 
>
> 最后附上 GitHub：<https://github.com/gonearewe>
