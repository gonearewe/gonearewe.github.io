---
layout: post
title: 让我们设计一个视频播放器
subtitle: 一个视频播放器的设计与实现系列（一）
date: 2021-05-26
author: John Mactavish
header-img: img/post-bg-red-dead-dear-dusk.jpg
catalog: true
tags:
  - 软件设计
  - JavaFX
  - Spring Boot
---

如题，今天我们要开始设计一个视频播放器（当然它也能播放音乐），主要用来熟悉 `Spring Boot`。

既然是冲着 `Spring Boot` 去的，语言必然用 `Java`；核心的视频播放功能
则选择 [vlcj](https://github.com/caprica/vlcj)，一个 `libvlc` （你应该知道大名鼎鼎的 [VLC 播放器](https://www.videolan.org/) 吧）的 `Java` 绑定库；`Java` 的 `GUI` 框架毫无疑问只能选 `JavaFX`，而根据 `vlcj` 所述，
`JavaFX 13` 引入的原生内存缓冲（`native memory buffer`） `PixelBuffer` 可以减少内存拷贝以提高性能，
所以我们一步到位，选用最新的 `JavaFX 16` 配合 `Java 11`；原生的 `GUI` 主题难以令人满意，
所以我们引入 `Win10` 风的 `JavaFX` 主题 [JMetro](https://pixelduke.com/java-javafx-theme-jmetro/)。

我们使用 `gradle` 来管理项目，构建 `build.gradle` 如下：

```groovy
import java.util.stream.Collectors

plugins {
    id 'java'
    id 'application'
    id 'org.openjfx.javafxplugin' version '0.0.10'
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

javafx {
    version = '16'
    modules = ['base', 'controls', 'fxml', 'graphics', 'media', 'swing', 'web'].stream().map {
        'javafx.' + it
    }.collect(Collectors.toList())
}

dependencies {
    implementation group: 'org.springframework.boot', name: 'spring-boot-starter', version: '2.5.0'

    ['base', 'controls', 'fxml', 'graphics', 'media', 'swing', 'web'].each {
        implementation group: 'org.openjfx', name: 'javafx-' + it, version: '16', classifier: 'win'
    }

    implementation group: 'org.jfxtras', name: 'jmetro', version: '11.6.15'

    implementation group: 'uk.co.caprica', name: 'vlcj', version: '4.7.1'

    implementation group: 'uk.co.caprica', name: 'vlcj-javafx', version: '1.0.2'

    // Use JUnit Jupiter API for testing.
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.1'

    // Use JUnit Jupiter Engine for testing.
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'

    // This dependency is used by the application.
    implementation 'com.google.guava:guava:30.0-jre'
}

application {
    // Define the main class for the application.
    mainClass = 'fun.mactavish.mplayer.App'
}

tasks.named('test') {
    // Use junit platform for unit tests.
    useJUnitPlatform()
}
```

`JavaFX` 有好几个依赖，它们仅仅是 name 不同（但 name 还有着相同的前缀），所以我们用 `Groovy` 的高阶函数语法简化它们的引入。
但是仅仅引入依赖还不够，因为 `JavaFX` 使用 `Java 9 Platform Module System`，
所以我们还要按[文档](https://openjfx.io/openjfx-docs/#gradle)要求引入 `gradle` 插件 `'org.openjfx.javafxplugin'` 并进行配置。
为了在 `vlcj` 基础上得到 `PixelBuffer` 支持，我们还需在 `'uk.co.caprica:vlcj'` 基础上引入 `'uk.co.caprica:vlcj-javafx'` 依赖。

接下来让我们写个 demo 验证一下一切正常。我们写一个引导类来初始化 `Spring Boot` 及 `JavaFX`。

```java
// Launcher.java
package fun.mactavish.mplayer;

import javafx.application.Application;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Launcher {
    public static void main(String[] args) {
        SpringApplication.run(Launcher.class, args);
        Application.launch(App.class, args);
    }
}
```

`SpringApplication` 的静态方法 `run` 接收一个带有 `@SpringBootApplication` 注解的类的类对象及命令行参数，
它会完成 `Spring Boot` 的初始化任务（解析配置参数、扫描组件、创建 `Bean`、注入依赖等）并返回一个类型为 `ConfigurableApplicationContext` 的
句柄，通过这个句柄可以读取配置参数、获取创建好的 `Bean` 等；
而 `Application` 的静态方法 `launch` 接收一个继承自 `javafx.application.Application` 的类的类对象及命令行参数，
它会初始化 `JavaFX` 并创建相关线程。

```java
// App.java
package fun.mactavish.mplayer;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
import jfxtras.styles.jmetro.JMetro;
import jfxtras.styles.jmetro.Style;

public class App extends Application {
    public App() {
    }

    @Override
    public void start(Stage primaryStage) {
        String javaVersion = System.getProperty("java.version");
        String javafxVersion = System.getProperty("javafx.version");

        Label l = new Label("Hello, JavaFX " + javafxVersion + ", running on Java " + javaVersion + ".");
        Scene scene = new Scene(new StackPane(l), 640, 480);
        new JMetro(Style.LIGHT).setScene(scene);

        primaryStage.setScene(scene);
        primaryStage.show();
    }
}
```

`JavaFX` 要求启动类不仅继承自 `javafx.application.Application`，还以 `public` 修饰自身且有 `public` 的无参构造函数。
在 `start` 方法中我们可以决定 `JavaFX` 初始化后干什么，这里我们先创建一个简单的 Hello World 界面。
其中仅需 `new JMetro(Style.LIGHT).setScene(scene);` 这么简单的一行，我们就引入了 `JMetro` 主题。

通过 `gradle run` 启动项目，应当可以看到一个 `GUI` 的欢迎界面，同时终端输出 `Spring Boot` 日志，关闭界面窗口程序即退出。
这是我们软件实现的基点。

---
> 本文代码在 <https://github.com/gonearewe/MPlayer/tree/65f846b305fbde77fd43465f1a57e98b679ff66d> 可以找到
---
如果你喜欢我的文章，请我吃根冰棒吧  (o゜▽゜)o ☆

![contribution](https://raw.githubusercontent.com/gonearewe/gonearewe.github.io/master/img/contribution.jpg)

> 最后附上 GitHub：<https://github.com/gonearewe>
